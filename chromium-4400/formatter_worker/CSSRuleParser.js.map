{"version":3,"file":"CSSRuleParser.js","sourceRoot":"","sources":["../../../../../front_end/formatter_worker/CSSRuleParser.js"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {createTokenizer} from './FormatterWorker.js';\n\nexport const CSSParserStates = {\n  Initial: 'Initial',\n  Selector: 'Selector',\n  Style: 'Style',\n  PropertyName: 'PropertyName',\n  PropertyValue: 'PropertyValue',\n  AtRule: 'AtRule'\n};\n\n/** @typedef {*} */\nlet Rule;  // eslint-disable-line no-unused-vars\n\n/**\n * @typedef {{ chunk: Array.<!Rule>, isLastChunk: boolean }} */\nlet Chunk;  // eslint-disable-line no-unused-vars\n\n/**\n * @param {string} text\n * @param {function({ chunk: !Array.<!Rule>, isLastChunk:boolean}):void} chunkCallback\n */\nexport function parseCSS(text, chunkCallback) {\n  const chunkSize = 100000;  // characters per data chunk\n  const lines = text.split('\\n');\n  /** @type {!Array.<!Rule>} */\n  let rules = [];\n  let processedChunkCharacters = 0;\n\n  let state = CSSParserStates.Initial;\n  /** @type {!Rule} */\n  let rule;\n  /** @type {*} */\n  let property;\n  const UndefTokenType = new Set();\n\n  /** @type {!Array.<!Rule>} */\n  let disabledRules = [];\n\n  /**\n   *\n   * @param {!Chunk} chunk\n   */\n  function disabledRulesCallback(chunk) {\n    disabledRules = disabledRules.concat(chunk.chunk);\n  }\n\n  /**\n   * @param {string} tokenValue\n   * @param {?string} tokenTypes\n   * @param {number} column\n   * @param {number} newColumn\n   */\n  function processToken(tokenValue, tokenTypes, column, newColumn) {\n    const tokenType = tokenTypes ? new Set(tokenTypes.split(' ')) : UndefTokenType;\n    switch (state) {\n      case CSSParserStates.Initial:\n        if (tokenType.has('qualifier') || tokenType.has('builtin') || tokenType.has('tag')) {\n          rule = {\n            selectorText: tokenValue,\n            lineNumber: lineNumber,\n            columnNumber: column,\n            properties: [],\n          };\n          state = CSSParserStates.Selector;\n        } else if (tokenType.has('def')) {\n          rule = {\n            atRule: tokenValue,\n            lineNumber: lineNumber,\n            columnNumber: column,\n          };\n          state = CSSParserStates.AtRule;\n        }\n        break;\n      case CSSParserStates.Selector:\n        if (tokenValue === '{' && tokenType === UndefTokenType) {\n          rule.selectorText = rule.selectorText.trim();\n          rule.styleRange = createRange(lineNumber, newColumn);\n          state = CSSParserStates.Style;\n        } else {\n          rule.selectorText += tokenValue;\n        }\n        break;\n      case CSSParserStates.AtRule:\n        if ((tokenValue === ';' || tokenValue === '{') && tokenType === UndefTokenType) {\n          rule.atRule = rule.atRule.trim();\n          rules.push(rule);\n          state = CSSParserStates.Initial;\n        } else {\n          rule.atRule += tokenValue;\n        }\n        break;\n      case CSSParserStates.Style:\n        if (tokenType.has('meta') || tokenType.has('property')) {\n          property = {\n            name: tokenValue,\n            value: '',\n            range: createRange(lineNumber, column),\n            nameRange: createRange(lineNumber, column)\n          };\n          state = CSSParserStates.PropertyName;\n        } else if (tokenValue === '}' && tokenType === UndefTokenType) {\n          rule.styleRange.endLine = lineNumber;\n          rule.styleRange.endColumn = column;\n          rules.push(rule);\n          state = CSSParserStates.Initial;\n        } else if (tokenType.has('comment')) {\n          // The |processToken| is called per-line, so no token spans more than one line.\n          // Support only a one-line comments.\n          if (tokenValue.substring(0, 2) !== '/*' || tokenValue.substring(tokenValue.length - 2) !== '*/') {\n            break;\n          }\n          const uncommentedText = tokenValue.substring(2, tokenValue.length - 2);\n          const fakeRule = 'a{\\n' + uncommentedText + '}';\n          disabledRules = [];\n          parseCSS(fakeRule, disabledRulesCallback);\n          if (disabledRules.length === 1 && disabledRules[0].properties.length === 1) {\n            const disabledProperty = disabledRules[0].properties[0];\n            disabledProperty.disabled = true;\n            disabledProperty.range = createRange(lineNumber, column);\n            disabledProperty.range.endColumn = newColumn;\n            const lineOffset = lineNumber - 1;\n            const columnOffset = column + 2;\n            disabledProperty.nameRange.startLine += lineOffset;\n            disabledProperty.nameRange.startColumn += columnOffset;\n            disabledProperty.nameRange.endLine += lineOffset;\n            disabledProperty.nameRange.endColumn += columnOffset;\n            disabledProperty.valueRange.startLine += lineOffset;\n            disabledProperty.valueRange.startColumn += columnOffset;\n            disabledProperty.valueRange.endLine += lineOffset;\n            disabledProperty.valueRange.endColumn += columnOffset;\n            rule.properties.push(disabledProperty);\n          }\n        }\n        break;\n      case CSSParserStates.PropertyName:\n        if (tokenValue === ':' && tokenType === UndefTokenType) {\n          property.name = property.name;\n          property.nameRange.endLine = lineNumber;\n          property.nameRange.endColumn = column;\n          property.valueRange = createRange(lineNumber, newColumn);\n          state = CSSParserStates.PropertyValue;\n        } else if (tokenType.has('property')) {\n          property.name += tokenValue;\n        }\n        break;\n      case CSSParserStates.PropertyValue:\n        if ((tokenValue === ';' || tokenValue === '}') && tokenType === UndefTokenType) {\n          property.value = property.value;\n          property.valueRange.endLine = lineNumber;\n          property.valueRange.endColumn = column;\n          property.range.endLine = lineNumber;\n          property.range.endColumn = tokenValue === ';' ? newColumn : column;\n          rule.properties.push(property);\n          if (tokenValue === '}') {\n            rule.styleRange.endLine = lineNumber;\n            rule.styleRange.endColumn = column;\n            rules.push(rule);\n            state = CSSParserStates.Initial;\n          } else {\n            state = CSSParserStates.Style;\n          }\n        } else if (!tokenType.has('comment')) {\n          property.value += tokenValue;\n        }\n        break;\n      default:\n        console.assert(false, 'Unknown CSS parser state.');\n    }\n    processedChunkCharacters += newColumn - column;\n    if (processedChunkCharacters > chunkSize) {\n      chunkCallback({chunk: rules, isLastChunk: false});\n      rules = [];\n      processedChunkCharacters = 0;\n    }\n  }\n  const tokenizer = createTokenizer('text/css');\n  /** @type {number} */\n  let lineNumber;\n  for (lineNumber = 0; lineNumber < lines.length; ++lineNumber) {\n    const line = lines[lineNumber];\n    tokenizer(line, processToken);\n    processToken('\\n', null, line.length, line.length + 1);\n  }\n  chunkCallback({chunk: rules, isLastChunk: true});\n\n  /**\n   * @param {number} lineNumber\n   * @param {number} columnNumber\n   * @return {!{startLine: number, startColumn: number, endLine: number, endColumn: number}}\n   */\n  function createRange(lineNumber, columnNumber) {\n    return {startLine: lineNumber, startColumn: columnNumber, endLine: lineNumber, endColumn: columnNumber};\n  }\n}\n"]}