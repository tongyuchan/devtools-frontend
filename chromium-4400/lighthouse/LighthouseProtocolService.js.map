{"version":3,"file":"LighthouseProtocolService.js","sourceRoot":"","sources":["../../../../../front_end/lighthouse/LighthouseProtocolService.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2018 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/* eslint-disable rulesdir/no_underscored_properties */\n\nimport * as Common from '../common/common.js';\nimport * as ProtocolClient from '../protocol_client/protocol_client.js';  // eslint-disable-line no-unused-vars\nimport * as SDK from '../sdk/sdk.js';\nimport * as Services from '../services/services.js';  // eslint-disable-line no-unused-vars\n\nimport * as ReportRenderer from './LighthouseReporterTypes.js';  // eslint-disable-line no-unused-vars\n\nexport class ProtocolService extends Common.ObjectWrapper.ObjectWrapper {\n  _rawConnection: ProtocolClient.InspectorBackend.Connection|null;\n  _backend: Services.ServiceManager.Service|null;\n  _backendPromise: Promise<void>|null;\n  _status: ((arg0: string) => void)|null;\n\n  constructor() {\n    super();\n    this._rawConnection = null;\n    this._backend = null;\n    this._backendPromise = null;\n    this._status = null;\n  }\n\n  async attach(): Promise<void> {\n    await SDK.SDKModel.TargetManager.instance().suspendAllTargets();\n    const mainTarget = SDK.SDKModel.TargetManager.instance().mainTarget();\n    if (!mainTarget) {\n      throw new Error('Unable to find main target required for LightHouse');\n    }\n    const childTargetManager = mainTarget.model(SDK.ChildTargetManager.ChildTargetManager);\n    if (!childTargetManager) {\n      throw new Error('Unable to find child target manager required for LightHouse');\n    }\n    this._rawConnection = await childTargetManager.createParallelConnection(message => {\n      if (typeof message === 'string') {\n        message = JSON.parse(message);\n      }\n      this._dispatchProtocolMessage(message);\n    });\n  }\n\n  getLocales(): readonly string[] {\n    return navigator.languages;\n  }\n\n  startLighthouse(auditURL: string, categoryIDs: string[], flags: Object): Promise<ReportRenderer.RunnerResult> {\n    const locales = this.getLocales();\n    return this._send('start', {url: auditURL, categoryIDs, flags, locales});\n  }\n\n  async detach(): Promise<void> {\n    await this._send('stop');\n    if (this._backend) {\n      await this._backend.dispose();\n      this._backend = null;\n    }\n    this._backendPromise = null;\n    if (this._rawConnection) {\n      await this._rawConnection.disconnect();\n    }\n    await SDK.SDKModel.TargetManager.instance().resumeAllTargets();\n  }\n\n  registerStatusCallback(callback: (arg0: string) => void): void {\n    this._status = callback;\n  }\n\n  _dispatchProtocolMessage(message: Object): void {\n    // A message without a sessionId is the main session of the main target (call it \"Main session\").\n    // A parallel connection and session was made that connects to the same main target (call it \"Lighthouse session\").\n    // Messages from the \"Lighthouse session\" have a sessionId.\n    // Without some care, there is a risk of sending the same events for the same main frame to Lighthouse–the backend\n    // will create events for the \"Main session\" and the \"Lighthouse session\".\n    // The workaround–only send message to Lighthouse if:\n    //   * the message has a sessionId (is not for the \"Main session\")\n    //   * the message does not have a sessionId (is for the \"Main session\"), but only for the Target domain\n    //     (to kickstart autoAttach in LH).\n    const protocolMessage = message as {\n      sessionId?: string;\n      method?: string;\n    };\n    if (protocolMessage.sessionId || (protocolMessage.method && protocolMessage.method.startsWith('Target'))) {\n      this._send('dispatchProtocolMessage', {message: JSON.stringify(message)});\n    }\n  }\n\n  _initWorker(): Promise<void> {\n    const backendPromise =\n        Services.serviceManager.createAppService('lighthouse_worker', 'LighthouseService').then(backend => {\n          if (this._backend) {\n            return;\n          }\n          this._backend = backend;\n          if (backend) {\n            backend.on('statusUpdate', (result?: {message?: string}) => {\n              if (this._status && result && 'message' in result) {\n                this._status(result.message as string);\n              }\n            });\n            backend.on('sendProtocolMessage', (result?: {message?: string}) => {\n              if (result && 'message' in result) {\n                this._sendProtocolMessage(result.message as string);\n              }\n            });\n          }\n        });\n    this._backendPromise = backendPromise;\n    return backendPromise;\n  }\n\n  _sendProtocolMessage(message: string): void {\n    if (this._rawConnection) {\n      this._rawConnection.sendRawMessage(message);\n    }\n  }\n\n  async _send(method: string, params?: {[x: string]: string|string[]|Object;}): Promise<ReportRenderer.RunnerResult> {\n    let backendPromise = this._backendPromise;\n    if (!backendPromise) {\n      backendPromise = this._initWorker();\n    }\n\n    await backendPromise;\n    if (!this._backend) {\n      throw new Error('Backend is missing to send LightHouse message to');\n    }\n    return this._backend.send(method, params) as Promise<ReportRenderer.RunnerResult>;\n  }\n}\n"]}