{"version":3,"file":"CoverageModel.js","sourceRoot":"","sources":["../../../../../front_end/coverage/CoverageModel.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/* eslint-disable rulesdir/no_underscored_properties */\n\nimport * as Bindings from '../bindings/bindings.js';  // eslint-disable-line no-unused-vars\nimport * as Common from '../common/common.js';\nimport * as Platform from '../platform/platform.js';\nimport * as SDK from '../sdk/sdk.js';\nimport * as TextUtils from '../text_utils/text_utils.js';\n\nexport const enum CoverageType {\n  CSS = (1 << 0),\n  JavaScript = (1 << 1),\n  JavaScriptPerFunction = (1 << 2)\n}\n\n\nexport const enum SuspensionState {\n  Active = 'Active',\n  Suspending = 'Suspending',\n  Suspended = 'Suspended'\n}\n\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  CoverageUpdated = 'CoverageUpdated',\n  CoverageReset = 'CoverageReset'\n}\n\n\nconst _coveragePollingPeriodMs: number = 200;\n\ninterface BacklogItem<T> {\n  rawCoverageData: Array<T>;\n  stamp: number;\n}\n\nexport class CoverageModel extends SDK.SDKModel.SDKModel {\n  _cpuProfilerModel: SDK.CPUProfilerModel.CPUProfilerModel|null;\n  _cssModel: SDK.CSSModel.CSSModel|null;\n  _debuggerModel: SDK.DebuggerModel.DebuggerModel|null;\n  _coverageByURL: Map<string, URLCoverageInfo>;\n  _coverageByContentProvider: Map<TextUtils.ContentProvider.ContentProvider, CoverageInfo>;\n  _coverageUpdateTimes: Set<number>;\n  _suspensionState: SuspensionState;\n  _pollTimer: number|null;\n  _currentPollPromise: Promise<void>|null;\n  _shouldResumePollingOnResume: boolean|null;\n  _jsBacklog: BacklogItem<Protocol.Profiler.ScriptCoverage>[];\n  _cssBacklog: BacklogItem<Protocol.CSS.RuleUsage>[];\n  _performanceTraceRecording: boolean|null;\n\n  constructor(target: SDK.SDKModel.Target) {\n    super(target);\n    this._cpuProfilerModel = target.model(SDK.CPUProfilerModel.CPUProfilerModel);\n    this._cssModel = target.model(SDK.CSSModel.CSSModel);\n    this._debuggerModel = target.model(SDK.DebuggerModel.DebuggerModel);\n\n    this._coverageByURL = new Map();\n    this._coverageByContentProvider = new Map();\n\n    // We keep track of the update times, because the other data-structures don't change if an\n    // update doesn't change the coverage. Some visualizations want to convey to the user that\n    // an update was received at a certain time, but did not result in a coverage change.\n    this._coverageUpdateTimes = new Set();\n\n    this._suspensionState = SuspensionState.Active;\n    this._pollTimer = null;\n    this._currentPollPromise = null;\n    this._shouldResumePollingOnResume = false;\n    this._jsBacklog = [];\n    this._cssBacklog = [];\n    this._performanceTraceRecording = false;\n  }\n\n  async start(jsCoveragePerBlock: boolean): Promise<boolean> {\n    if (this._suspensionState !== SuspensionState.Active) {\n      throw Error('Cannot start CoverageModel while it is not active.');\n    }\n    const promises = [];\n    if (this._cssModel) {\n      // Note there's no JS coverage since JS won't ever return\n      // coverage twice, even after it's restarted.\n      this._clearCSS();\n\n      this._cssModel.addEventListener(SDK.CSSModel.Events.StyleSheetAdded, this._handleStyleSheetAdded, this);\n      promises.push(this._cssModel.startCoverage());\n    }\n    if (this._cpuProfilerModel) {\n      promises.push(\n          this._cpuProfilerModel.startPreciseCoverage(jsCoveragePerBlock, this.preciseCoverageDeltaUpdate.bind(this)));\n    }\n\n    await Promise.all(promises);\n    return Boolean(this._cssModel || this._cpuProfilerModel);\n  }\n\n  preciseCoverageDeltaUpdate(timestamp: number, occasion: string, coverageData: Protocol.Profiler.ScriptCoverage[]):\n      void {\n    this._coverageUpdateTimes.add(timestamp);\n    this._backlogOrProcessJSCoverage(coverageData, timestamp);\n  }\n\n  async stop(): Promise<void> {\n    await this.stopPolling();\n    const promises = [];\n    if (this._cpuProfilerModel) {\n      promises.push(this._cpuProfilerModel.stopPreciseCoverage());\n    }\n    if (this._cssModel) {\n      promises.push(this._cssModel.stopCoverage());\n      this._cssModel.removeEventListener(SDK.CSSModel.Events.StyleSheetAdded, this._handleStyleSheetAdded, this);\n    }\n    await Promise.all(promises);\n  }\n\n  reset(): void {\n    this._coverageByURL = new Map();\n    this._coverageByContentProvider = new Map();\n    this._coverageUpdateTimes = new Set();\n    this.dispatchEventToListeners(Events.CoverageReset);\n  }\n\n  async startPolling(): Promise<void> {\n    if (this._currentPollPromise || this._suspensionState !== SuspensionState.Active) {\n      return;\n    }\n    await this._pollLoop();\n  }\n\n  async _pollLoop(): Promise<void> {\n    this._clearTimer();\n    this._currentPollPromise = this._pollAndCallback();\n    await this._currentPollPromise;\n    if (this._suspensionState === SuspensionState.Active || this._performanceTraceRecording) {\n      this._pollTimer = window.setTimeout(() => this._pollLoop(), _coveragePollingPeriodMs);\n    }\n  }\n\n  async stopPolling(): Promise<void> {\n    this._clearTimer();\n    await this._currentPollPromise;\n    this._currentPollPromise = null;\n    // Do one last poll to get the final data.\n    await this._pollAndCallback();\n  }\n\n  async _pollAndCallback(): Promise<void> {\n    if (this._suspensionState === SuspensionState.Suspended && !this._performanceTraceRecording) {\n      return;\n    }\n    const updates = await this._takeAllCoverage();\n    // This conditional should never trigger, as all intended ways to stop\n    // polling are awaiting the `_currentPollPromise` before suspending.\n    console.assert(\n        this._suspensionState !== SuspensionState.Suspended || Boolean(this._performanceTraceRecording),\n        'CoverageModel was suspended while polling.');\n    if (updates.length) {\n      this.dispatchEventToListeners(Events.CoverageUpdated, updates);\n    }\n  }\n\n  _clearTimer(): void {\n    if (this._pollTimer) {\n      clearTimeout(this._pollTimer);\n      this._pollTimer = null;\n    }\n  }\n\n  /**\n   * Stops polling as preparation for suspension. This function is idempotent\n   * due because it changes the state to suspending.\n   */\n  async preSuspendModel(reason?: string): Promise<void> {\n    if (this._suspensionState !== SuspensionState.Active) {\n      return;\n    }\n    this._suspensionState = SuspensionState.Suspending;\n    if (reason === 'performance-timeline') {\n      this._performanceTraceRecording = true;\n      // Keep polling to the backlog if a performance trace is recorded.\n      return;\n    }\n    if (this._currentPollPromise) {\n      await this.stopPolling();\n      this._shouldResumePollingOnResume = true;\n    }\n  }\n\n  async suspendModel(_reason?: string): Promise<void> {\n    this._suspensionState = SuspensionState.Suspended;\n  }\n\n  async resumeModel(): Promise<void> {\n  }\n\n  /**\n   * Restarts polling after suspension. Note that the function is idempotent\n   * because starting polling is idempotent.\n   */\n  async postResumeModel(): Promise<void> {\n    this._suspensionState = SuspensionState.Active;\n    this._performanceTraceRecording = false;\n    if (this._shouldResumePollingOnResume) {\n      this._shouldResumePollingOnResume = false;\n      await this.startPolling();\n    }\n  }\n\n  entries(): URLCoverageInfo[] {\n    return Array.from(this._coverageByURL.values());\n  }\n\n  getCoverageForUrl(url: string): URLCoverageInfo|null {\n    return this._coverageByURL.get(url) || null;\n  }\n\n  usageForRange(contentProvider: TextUtils.ContentProvider.ContentProvider, startOffset: number, endOffset: number):\n      boolean|undefined {\n    const coverageInfo = this._coverageByContentProvider.get(contentProvider);\n    return coverageInfo && coverageInfo.usageForRange(startOffset, endOffset);\n  }\n\n  _clearCSS(): void {\n    for (const entry of this._coverageByContentProvider.values()) {\n      if (entry.type() !== CoverageType.CSS) {\n        continue;\n      }\n      const contentProvider = entry.contentProvider() as SDK.CSSStyleSheetHeader.CSSStyleSheetHeader;\n      this._coverageByContentProvider.delete(contentProvider);\n      const key = `${contentProvider.startLine}:${contentProvider.startColumn}`;\n      const urlEntry = this._coverageByURL.get(entry.url());\n      if (!urlEntry || !urlEntry._coverageInfoByLocation.delete(key)) {\n        continue;\n      }\n      urlEntry._addToSizes(-entry._usedSize, -entry._size);\n      if (!urlEntry._coverageInfoByLocation.size) {\n        this._coverageByURL.delete(entry.url());\n      }\n    }\n\n    if (this._cssModel) {\n      for (const styleSheetHeader of this._cssModel.getAllStyleSheetHeaders()) {\n        this._addStyleSheetToCSSCoverage(styleSheetHeader);\n      }\n    }\n  }\n\n  async _takeAllCoverage(): Promise<CoverageInfo[]> {\n    const [updatesCSS, updatesJS] = await Promise.all([this._takeCSSCoverage(), this._takeJSCoverage()]);\n    return [...updatesCSS, ...updatesJS];\n  }\n\n  async _takeJSCoverage(): Promise<CoverageInfo[]> {\n    if (!this._cpuProfilerModel) {\n      return [];\n    }\n    const {coverage, timestamp} = await this._cpuProfilerModel.takePreciseCoverage();\n    this._coverageUpdateTimes.add(timestamp);\n    return this._backlogOrProcessJSCoverage(coverage, timestamp);\n  }\n\n  coverageUpdateTimes(): Set<number> {\n    return this._coverageUpdateTimes;\n  }\n\n  async _backlogOrProcessJSCoverage(freshRawCoverageData: Protocol.Profiler.ScriptCoverage[], freshTimestamp: number):\n      Promise<CoverageInfo[]> {\n    if (freshRawCoverageData.length > 0) {\n      this._jsBacklog.push({rawCoverageData: freshRawCoverageData, stamp: freshTimestamp});\n    }\n    if (this._suspensionState !== SuspensionState.Active) {\n      return [];\n    }\n    const ascendingByTimestamp = (x: {stamp: number;}, y: {stamp: number;}): number => x.stamp - y.stamp;\n    const results = [];\n    for (const {rawCoverageData, stamp} of this._jsBacklog.sort(ascendingByTimestamp)) {\n      results.push(this._processJSCoverage(rawCoverageData, stamp));\n    }\n    this._jsBacklog = [];\n    return results.flat();\n  }\n\n  async processJSBacklog(): Promise<void> {\n    this._backlogOrProcessJSCoverage([], 0);\n  }\n\n  _processJSCoverage(scriptsCoverage: Protocol.Profiler.ScriptCoverage[], stamp: number): CoverageInfo[] {\n    if (!this._debuggerModel) {\n      return [];\n    }\n    const updatedEntries = [];\n    for (const entry of scriptsCoverage) {\n      const script = this._debuggerModel.scriptForId(entry.scriptId);\n      if (!script) {\n        continue;\n      }\n\n      const ranges = [];\n      let type = CoverageType.JavaScript;\n      for (const func of entry.functions) {\n        // Do not coerce undefined to false, i.e. only consider blockLevel to be false\n        // if back-end explicitly provides blockLevel field, otherwise presume blockLevel\n        // coverage is not available. Also, ignore non-block level functions that weren't\n        // ever called.\n        if (func.isBlockCoverage === false && !(func.ranges.length === 1 && !func.ranges[0].count)) {\n          type |= CoverageType.JavaScriptPerFunction;\n        }\n        for (const range of func.ranges) {\n          ranges.push(range);\n        }\n      }\n      const subentry = this._addCoverage(\n          script, script.contentLength, script.lineOffset, script.columnOffset, ranges, type as CoverageType, stamp);\n      if (subentry) {\n        updatedEntries.push(subentry);\n      }\n    }\n    return updatedEntries;\n  }\n\n  _handleStyleSheetAdded(event: Common.EventTarget.EventTargetEvent): void {\n    const styleSheetHeader = event.data as SDK.CSSStyleSheetHeader.CSSStyleSheetHeader;\n\n    this._addStyleSheetToCSSCoverage(styleSheetHeader);\n  }\n\n  async _takeCSSCoverage(): Promise<CoverageInfo[]> {\n    // Don't poll if we have no model, or are suspended.\n    if (!this._cssModel || this._suspensionState !== SuspensionState.Active) {\n      return [];\n    }\n    const {coverage, timestamp} = await this._cssModel.takeCoverageDelta();\n    this._coverageUpdateTimes.add(timestamp);\n    return this._backlogOrProcessCSSCoverage(coverage, timestamp);\n  }\n\n  async _backlogOrProcessCSSCoverage(freshRawCoverageData: Protocol.CSS.RuleUsage[], freshTimestamp: number):\n      Promise<CoverageInfo[]> {\n    if (freshRawCoverageData.length > 0) {\n      this._cssBacklog.push({rawCoverageData: freshRawCoverageData, stamp: freshTimestamp});\n    }\n    if (this._suspensionState !== SuspensionState.Active) {\n      return [];\n    }\n    const ascendingByTimestamp = (x: {stamp: number;}, y: {stamp: number;}): number => x.stamp - y.stamp;\n    const results = [];\n    for (const {rawCoverageData, stamp} of this._cssBacklog.sort(ascendingByTimestamp)) {\n      results.push(this._processCSSCoverage(rawCoverageData, stamp));\n    }\n    this._cssBacklog = [];\n    return results.flat();\n  }\n\n  _processCSSCoverage(ruleUsageList: Protocol.CSS.RuleUsage[], stamp: number): CoverageInfo[] {\n    if (!this._cssModel) {\n      return [];\n    }\n    const updatedEntries = [];\n    const rulesByStyleSheet = new Map<SDK.CSSStyleSheetHeader.CSSStyleSheetHeader, RangeUseCount[]>();\n    for (const rule of ruleUsageList) {\n      const styleSheetHeader = this._cssModel.styleSheetHeaderForId(rule.styleSheetId);\n      if (!styleSheetHeader) {\n        continue;\n      }\n      let ranges = rulesByStyleSheet.get(styleSheetHeader);\n      if (!ranges) {\n        ranges = [];\n        rulesByStyleSheet.set(styleSheetHeader, ranges);\n      }\n      ranges.push({startOffset: rule.startOffset, endOffset: rule.endOffset, count: Number(rule.used)});\n    }\n    for (const entry of rulesByStyleSheet) {\n      const styleSheetHeader = entry[0] as SDK.CSSStyleSheetHeader.CSSStyleSheetHeader;\n      const ranges = entry[1] as RangeUseCount[];\n      const subentry = this._addCoverage(\n          styleSheetHeader, styleSheetHeader.contentLength, styleSheetHeader.startLine, styleSheetHeader.startColumn,\n          ranges, CoverageType.CSS, stamp);\n      if (subentry) {\n        updatedEntries.push(subentry);\n      }\n    }\n    return updatedEntries;\n  }\n\n  static _convertToDisjointSegments(ranges: RangeUseCount[], stamp: number): CoverageSegment[] {\n    ranges.sort((a, b) => a.startOffset - b.startOffset);\n\n    const result: CoverageSegment[] = [];\n    const stack = [];\n    for (const entry of ranges) {\n      let top: RangeUseCount = stack[stack.length - 1];\n      while (top && top.endOffset <= entry.startOffset) {\n        append(top.endOffset, top.count);\n        stack.pop();\n        top = stack[stack.length - 1];\n      }\n      append(entry.startOffset, top ? top.count : 0);\n      stack.push(entry);\n    }\n\n    for (let top = stack.pop(); top; top = stack.pop()) {\n      append(top.endOffset, top.count);\n    }\n\n    function append(end: number, count: number): void {\n      const last = result[result.length - 1];\n      if (last) {\n        if (last.end === end) {\n          return;\n        }\n        if (last.count === count) {\n          last.end = end;\n          return;\n        }\n      }\n      result.push({end: end, count: count, stamp: stamp});\n    }\n\n    return result;\n  }\n\n  _addStyleSheetToCSSCoverage(styleSheetHeader: SDK.CSSStyleSheetHeader.CSSStyleSheetHeader): void {\n    this._addCoverage(\n        styleSheetHeader, styleSheetHeader.contentLength, styleSheetHeader.startLine, styleSheetHeader.startColumn, [],\n        CoverageType.CSS, Date.now());\n  }\n\n  _addCoverage(\n      contentProvider: TextUtils.ContentProvider.ContentProvider, contentLength: number, startLine: number,\n      startColumn: number, ranges: RangeUseCount[], type: CoverageType, stamp: number): CoverageInfo|null {\n    const url = contentProvider.contentURL();\n    if (!url) {\n      return null;\n    }\n    let urlCoverage = this._coverageByURL.get(url);\n    let isNewUrlCoverage = false;\n    if (!urlCoverage) {\n      isNewUrlCoverage = true;\n      urlCoverage = new URLCoverageInfo(url);\n      this._coverageByURL.set(url, urlCoverage);\n    }\n\n    const coverageInfo = urlCoverage._ensureEntry(contentProvider, contentLength, startLine, startColumn, type);\n    this._coverageByContentProvider.set(contentProvider, coverageInfo);\n    const segments = CoverageModel._convertToDisjointSegments(ranges, stamp);\n    const last = segments[segments.length - 1];\n    if (last && last.end < contentLength) {\n      segments.push({end: contentLength, stamp: stamp, count: 0});\n    }\n    const oldUsedSize = coverageInfo._usedSize;\n    coverageInfo.mergeCoverage(segments);\n    if (!isNewUrlCoverage && coverageInfo._usedSize === oldUsedSize) {\n      return null;\n    }\n    urlCoverage._addToSizes(coverageInfo._usedSize - oldUsedSize, 0);\n    return coverageInfo;\n  }\n\n  async exportReport(fos: Bindings.FileUtils.FileOutputStream): Promise<void> {\n    const result: {url: string; ranges: {start: number; end: number;}[]; text: string | null;}[] = [];\n    function locationCompare(a: string, b: string): number {\n      const [aLine, aPos] = a.split(':');\n      const [bLine, bPos] = b.split(':');\n      return Number.parseInt(aLine, 10) - Number.parseInt(bLine, 10) ||\n          Number.parseInt(aPos, 10) - Number.parseInt(bPos, 10);\n    }\n    const coverageByUrlKeys = Array.from(this._coverageByURL.keys()).sort();\n    for (const urlInfoKey of coverageByUrlKeys) {\n      const urlInfo = this._coverageByURL.get(urlInfoKey);\n      if (!urlInfo) {\n        continue;\n      }\n      const url = urlInfo.url();\n      if (url.startsWith('extensions::') || url.startsWith('chrome-extension://')) {\n        continue;\n      }\n\n      // For .html resources, multiple scripts share URL, but have different offsets.\n      let useFullText = false;\n      for (const info of urlInfo._coverageInfoByLocation.values()) {\n        if (info._lineOffset || info._columnOffset) {\n          useFullText = Boolean(url);\n          break;\n        }\n      }\n\n      let fullText: TextUtils.Text.Text|null = null;\n      if (useFullText) {\n        const resource = SDK.ResourceTreeModel.ResourceTreeModel.resourceForURL(url);\n        if (resource) {\n          const content = (await resource.requestContent()).content;\n          fullText = new TextUtils.Text.Text(content || '');\n        }\n      }\n\n      const coverageByLocationKeys = Array.from(urlInfo._coverageInfoByLocation.keys()).sort(locationCompare);\n\n      // We have full text for this resource, resolve the offsets using the text line endings.\n      if (fullText) {\n        const entry: {url: string; ranges: {start: number; end: number;}[];\n                      text: string;} = {url, ranges: [], text: fullText.value()};\n        for (const infoKey of coverageByLocationKeys) {\n          const info = urlInfo._coverageInfoByLocation.get(infoKey);\n          if (!info) {\n            continue;\n          }\n          const offset = fullText ? fullText.offsetFromPosition(info._lineOffset, info._columnOffset) : 0;\n          let start = 0;\n          for (const segment of info._segments) {\n            if (segment.count) {\n              entry.ranges.push({start: start + offset, end: segment.end + offset});\n            } else {\n              start = segment.end;\n            }\n          }\n        }\n        result.push(entry);\n        continue;\n      }\n\n      // Fall back to the per-script operation.\n      for (const infoKey of coverageByLocationKeys) {\n        const info = urlInfo._coverageInfoByLocation.get(infoKey);\n        if (!info) {\n          continue;\n        }\n        const entry: {url: string; ranges: {start: number; end: number;}[]; text: string |\n                          null;} = {url, ranges: [], text: (await info.contentProvider().requestContent()).content};\n        let start = 0;\n        for (const segment of info._segments) {\n          if (segment.count) {\n            entry.ranges.push({start: start, end: segment.end});\n          } else {\n            start = segment.end;\n          }\n        }\n        result.push(entry);\n      }\n    }\n    await fos.write(JSON.stringify(result, undefined, 2));\n    fos.close();\n  }\n}\n\nSDK.SDKModel.SDKModel.register(CoverageModel, SDK.SDKModel.Capability.None, false);\n\nexport class URLCoverageInfo extends Common.ObjectWrapper.ObjectWrapper {\n  _url: string;\n  _coverageInfoByLocation: Map<string, CoverageInfo>;\n  _size: number;\n  _usedSize: number;\n  _type!: CoverageType;\n  _isContentScript: boolean;\n  constructor(url: string) {\n    super();\n\n    this._url = url;\n    this._coverageInfoByLocation = new Map();\n    this._size = 0;\n    this._usedSize = 0;\n    this._isContentScript = false;\n  }\n\n  url(): string {\n    return this._url;\n  }\n\n  type(): CoverageType {\n    return this._type;\n  }\n\n  size(): number {\n    return this._size;\n  }\n\n  usedSize(): number {\n    return this._usedSize;\n  }\n\n  unusedSize(): number {\n    return this._size - this._usedSize;\n  }\n\n  usedPercentage(): number {\n    // Per convention, empty files are reported as 100 % uncovered\n    if (this._size === 0) {\n      return 0;\n    }\n    return this.usedSize() / this.size() * 100;\n  }\n\n  unusedPercentage(): number {\n    // Per convention, empty files are reported as 100 % uncovered\n    if (this._size === 0) {\n      return 100;\n    }\n    return this.unusedSize() / this.size() * 100;\n  }\n\n  isContentScript(): boolean {\n    return this._isContentScript;\n  }\n\n  entries(): IterableIterator<CoverageInfo> {\n    return this._coverageInfoByLocation.values();\n  }\n\n  _addToSizes(usedSize: number, size: number): void {\n    this._usedSize += usedSize;\n    this._size += size;\n\n    if (usedSize !== 0 || size !== 0) {\n      this.dispatchEventToListeners(URLCoverageInfo.Events.SizesChanged);\n    }\n  }\n\n  _ensureEntry(\n      contentProvider: TextUtils.ContentProvider.ContentProvider, contentLength: number, lineOffset: number,\n      columnOffset: number, type: CoverageType): CoverageInfo {\n    const key = `${lineOffset}:${columnOffset}`;\n    let entry = this._coverageInfoByLocation.get(key);\n\n    if ((type & CoverageType.JavaScript) && !this._coverageInfoByLocation.size) {\n      this._isContentScript = (contentProvider as SDK.Script.Script).isContentScript();\n    }\n    this._type |= type;\n\n    if (entry) {\n      entry._coverageType |= type;\n      return entry;\n    }\n\n    if ((type & CoverageType.JavaScript) && !this._coverageInfoByLocation.size) {\n      this._isContentScript = (contentProvider as SDK.Script.Script).isContentScript();\n    }\n\n    entry = new CoverageInfo(contentProvider, contentLength, lineOffset, columnOffset, type);\n    this._coverageInfoByLocation.set(key, entry);\n    this._addToSizes(0, contentLength);\n\n    return entry;\n  }\n\n  static readonly Events = {\n    SizesChanged: Symbol('SizesChanged'),\n  };\n}\n\nexport const mergeSegments = (segmentsA: CoverageSegment[], segmentsB: CoverageSegment[]): CoverageSegment[] => {\n  const result: CoverageSegment[] = [];\n\n  let indexA = 0;\n  let indexB = 0;\n  while (indexA < segmentsA.length && indexB < segmentsB.length) {\n    const a = segmentsA[indexA];\n    const b = segmentsB[indexB];\n    const count = (a.count || 0) + (b.count || 0);\n    const end = Math.min(a.end, b.end);\n    const last = result[result.length - 1];\n    const stamp = Math.min(a.stamp, b.stamp);\n    if (!last || last.count !== count || last.stamp !== stamp) {\n      result.push({end: end, count: count, stamp: stamp});\n    } else {\n      last.end = end;\n    }\n    if (a.end <= b.end) {\n      indexA++;\n    }\n    if (a.end >= b.end) {\n      indexB++;\n    }\n  }\n\n  for (; indexA < segmentsA.length; indexA++) {\n    result.push(segmentsA[indexA]);\n  }\n  for (; indexB < segmentsB.length; indexB++) {\n    result.push(segmentsB[indexB]);\n  }\n  return result;\n};\n\nexport class CoverageInfo {\n  _contentProvider: TextUtils.ContentProvider.ContentProvider;\n  _size: number;\n  _usedSize: number;\n  _statsByTimestamp: Map<number, number>;\n  _lineOffset: number;\n  _columnOffset: number;\n  _coverageType: CoverageType;\n  _segments: CoverageSegment[];\n  constructor(\n      contentProvider: TextUtils.ContentProvider.ContentProvider, size: number, lineOffset: number,\n      columnOffset: number, type: CoverageType) {\n    this._contentProvider = contentProvider;\n    this._size = size;\n    this._usedSize = 0;\n    this._statsByTimestamp = new Map();\n    this._lineOffset = lineOffset;\n    this._columnOffset = columnOffset;\n    this._coverageType = type;\n\n    this._segments = [];\n  }\n\n  contentProvider(): TextUtils.ContentProvider.ContentProvider {\n    return this._contentProvider;\n  }\n\n  url(): string {\n    return this._contentProvider.contentURL();\n  }\n\n  type(): CoverageType {\n    return this._coverageType;\n  }\n\n  mergeCoverage(segments: CoverageSegment[]): void {\n    this._segments = mergeSegments(this._segments, segments);\n    this._updateStats();\n  }\n\n  usedByTimestamp(): Map<number, number> {\n    return this._statsByTimestamp;\n  }\n\n  size(): number {\n    return this._size;\n  }\n\n  usageForRange(start: number, end: number): boolean {\n    let index =\n        Platform.ArrayUtilities.upperBound(this._segments, start, (position, segment) => position - segment.end);\n    for (; index < this._segments.length && this._segments[index].end < end; ++index) {\n      if (this._segments[index].count) {\n        return true;\n      }\n    }\n    return index < this._segments.length && Boolean(this._segments[index].count);\n  }\n  _updateStats(): void {\n    this._statsByTimestamp = new Map();\n    this._usedSize = 0;\n\n    let last = 0;\n    for (const segment of this._segments) {\n      let previousCount = this._statsByTimestamp.get(segment.stamp);\n      if (previousCount === undefined) {\n        previousCount = 0;\n      }\n\n      if (segment.count) {\n        const used = segment.end - last;\n        this._usedSize += used;\n        this._statsByTimestamp.set(segment.stamp, previousCount + used);\n      }\n      last = segment.end;\n    }\n  }\n}\nexport interface RangeUseCount {\n  startOffset: number;\n  endOffset: number;\n  count: number;\n}\nexport interface CoverageSegment {\n  end: number;\n  count: number;\n  stamp: number;\n}\n"]}