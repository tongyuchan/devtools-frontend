{"version":3,"file":"ValueInterpreterDisplayUtils.js","sourceRoot":"","sources":["../../../../../front_end/linear_memory_inspector/ValueInterpreterDisplayUtils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../common/common.js';\nimport * as Platform from '../platform/platform.js';\nconst ls = Common.ls;\n\nexport const VALUE_INTEPRETER_MAX_NUM_BYTES = 8;\n\nexport const enum ValueType {\n  Int8 = 'Integer 8-bit',\n  Int16 = 'Integer 16-bit',\n  Int32 = 'Integer 32-bit',\n  Int64 = 'Integer 64-bit',\n  Float32 = 'Float 32-bit',\n  Float64 = 'Float 64-bit',\n  String = 'String'\n}\n\nexport const enum Endianness {\n  Little = 'Little Endian',\n  Big = 'Big Endian'\n}\n\nexport const enum ValueTypeMode {\n  Decimal = 'dec',\n  Hexadecimal = 'hex',\n  Octal = 'oct',\n  Scientific = 'sci',\n  None = 'none'\n}\n\nexport function valueTypeModeToLocalizedString(mode: ValueTypeMode): string {\n  switch (mode) {\n    case ValueTypeMode.Decimal:\n      return ls`dec`;\n    case ValueTypeMode.Hexadecimal:\n      return ls`hex`;\n    case ValueTypeMode.Octal:\n      return ls`oct`;\n    case ValueTypeMode.Scientific:\n      return ls`sci`;\n    case ValueTypeMode.None:\n      return ls`none`;\n    default:\n      return Platform.assertNever(mode, `Unknown mode: ${mode}`);\n  }\n}\n\nexport function endiannessToLocalizedString(endianness: Endianness): string {\n  switch (endianness) {\n    case Endianness.Little:\n      return ls`Little Endian`;\n    case Endianness.Big:\n      return ls`Big Endian`;\n    default:\n      return Platform.assertNever(endianness, `Unknown endianness: ${endianness}`);\n  }\n}\n\nexport function valueTypeToLocalizedString(valueType: ValueType): string {\n  switch (valueType) {\n    case ValueType.Int8:\n      return ls`Integer 8-bit`;\n    case ValueType.Int16:\n      return ls`Integer 16-bit`;\n    case ValueType.Int32:\n      return ls`Integer 32-bit`;\n    case ValueType.Int64:\n      return ls`Integer 64-bit`;\n    case ValueType.Float32:\n      return ls`Float 32-bit`;\n    case ValueType.Float64:\n      return ls`Float 64-bit`;\n    case ValueType.String:\n      return ls`String`;\n    default:\n      return Platform.assertNever(valueType, `Unknown value type: ${valueType}`);\n  }\n}\n\nexport function isValidMode(type: ValueType, mode: ValueTypeMode): boolean {\n  switch (type) {\n    case ValueType.Int8:\n    case ValueType.Int16:\n    case ValueType.Int32:\n    case ValueType.Int64:\n      return mode === ValueTypeMode.Decimal || mode === ValueTypeMode.Hexadecimal || mode === ValueTypeMode.Octal;\n    case ValueType.Float32:\n    case ValueType.Float64:\n      return mode === ValueTypeMode.Scientific || mode === ValueTypeMode.Decimal;\n    case ValueType.String:\n      return mode === ValueTypeMode.None;\n    default:\n      return Platform.assertNever(type, `Unknown value type: ${type}`);\n  }\n}\n\nexport function isNumber(type: ValueType): boolean {\n  switch (type) {\n    case ValueType.Int8:\n    case ValueType.Int16:\n    case ValueType.Int32:\n    case ValueType.Int64:\n    case ValueType.Float32:\n    case ValueType.Float64:\n      return true;\n    default:\n      return false;\n  }\n}\n\nexport interface FormatData {\n  buffer: ArrayBuffer;\n  type: ValueType;\n  endianness: Endianness;\n  signed: boolean;\n  mode: ValueTypeMode;\n}\n\nexport function format(formatData: FormatData): string {\n  const valueView = new DataView(formatData.buffer);\n  const isLittleEndian = formatData.endianness === Endianness.Little;\n  let value;\n\n  try {\n    switch (formatData.type) {\n      case ValueType.Int8:\n        value = formatData.signed ? valueView.getInt8(0) : valueView.getUint8(0);\n        return formatInteger(value, formatData.mode);\n      case ValueType.Int16:\n        value = formatData.signed ? valueView.getInt16(0, isLittleEndian) : valueView.getUint16(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.Int32:\n        value = formatData.signed ? valueView.getInt32(0, isLittleEndian) : valueView.getUint32(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.Int64:\n        value =\n            formatData.signed ? valueView.getBigInt64(0, isLittleEndian) : valueView.getBigUint64(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.Float32:\n        value = valueView.getFloat32(0, isLittleEndian);\n        return formatFloat(value, formatData.mode);\n      case ValueType.Float64:\n        value = valueView.getFloat64(0, isLittleEndian);\n        return formatFloat(value, formatData.mode);\n      case ValueType.String:\n        throw new Error(`Type ${formatData.type} is not yet implemented`);\n      default:\n        return Platform.assertNever(formatData.type, `Unknown value type: ${formatData.type}`);\n    }\n  } catch (e) {\n    return 'N/A';\n  }\n}\n\nexport function formatFloat(value: number, mode: ValueTypeMode): string {\n  switch (mode) {\n    case ValueTypeMode.Decimal:\n      return value.toFixed(2).toString();\n    case ValueTypeMode.Scientific:\n      return value.toExponential(2).toString();\n    default:\n      throw new Error(`Unknown mode for floats: ${mode}.`);\n  }\n}\n\nexport function formatInteger(value: number|bigint, mode: ValueTypeMode): string {\n  switch (mode) {\n    case ValueTypeMode.Decimal:\n      return value.toString();\n    case ValueTypeMode.Hexadecimal:\n      return value.toString(16);\n    case ValueTypeMode.Octal:\n      return value.toString(8);\n    default:\n      throw new Error(`Unknown mode for integers: ${mode}.`);\n  }\n}\n"]}