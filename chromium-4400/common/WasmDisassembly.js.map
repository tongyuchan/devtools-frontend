{"version":3,"file":"WasmDisassembly.js","sourceRoot":"","sources":["../../../../../front_end/common/WasmDisassembly.js"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B;;;GAGG;AACH,MAAM,OAAO,eAAe;IAC1B;;;OAGG;IACH,YAAY,OAAO,EAAE,mBAAmB;QACtC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,oBAAoB,GAAG,mBAAmB,CAAC;IAClD,CAAC;IAED,uBAAuB;IACvB,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;IAC9B,CAAC;IAED;;;OAGG;IACH,0BAA0B,CAAC,cAAc;QACvC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;QACxC,OAAO,CAAC,IAAI,CAAC,EAAE;YACb,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAClC,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAChC,IAAI,MAAM,GAAG,cAAc,EAAE;gBAC3B,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;aACX;iBAAM,IAAI,MAAM,GAAG,cAAc,EAAE;gBAClC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;aACX;iBAAM;gBACL,OAAO,CAAC,CAAC;aACV;SACF;QACD,OAAO,CAAC,CAAC;IACX,CAAC;IAED;;;OAGG;IACH,0BAA0B,CAAC,UAAU;QACnC,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;IACnC,CAAC;IAED;;OAEG;IACH,CAAE,uBAAuB;QACvB,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,IAAI,aAAa,GAAG,CAAC,CAAC;QACtB,OAAO,UAAU,GAAG,IAAI,CAAC,WAAW,EAAE;YACpC,IAAI,aAAa,GAAG,IAAI,CAAC,oBAAoB,CAAC,MAAM,EAAE;gBACpD,MAAM,MAAM,GAAG,IAAI,CAAC,0BAA0B,CAAC,UAAU,CAAC,CAAC;gBAC3D,IAAI,MAAM,IAAI,IAAI,CAAC,oBAAoB,CAAC,aAAa,CAAC,CAAC,KAAK,EAAE;oBAC5D,UAAU,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,oBAAoB,CAAC,aAAa,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;oBAC7F,SAAS;iBACV;aACF;YACD,MAAM,UAAU,EAAE,CAAC;SACpB;IACH,CAAC;CACF","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * Metadata to map between bytecode offsets and line numbers in the\n * disassembly for WebAssembly modules.\n */\nexport class WasmDisassembly {\n  /**\n   * @param {!Array<number>} offsets mapping of line numbers to bytecode offsets\n   * @param {!Array<{start: number, end: number}>} functionBodyOffsets mapping of function indices to start/end bytecode offsets\n   */\n  constructor(offsets, functionBodyOffsets) {\n    this._offsets = offsets;\n    this._functionBodyOffsets = functionBodyOffsets;\n  }\n\n  /** @return {number} */\n  get lineNumbers() {\n    return this._offsets.length;\n  }\n\n  /**\n   * @param {number} bytecodeOffset\n   * @return {number}\n   */\n  bytecodeOffsetToLineNumber(bytecodeOffset) {\n    let l = 0, r = this._offsets.length - 1;\n    while (l <= r) {\n      const m = Math.floor((l + r) / 2);\n      const offset = this._offsets[m];\n      if (offset < bytecodeOffset) {\n        l = m + 1;\n      } else if (offset > bytecodeOffset) {\n        r = m - 1;\n      } else {\n        return m;\n      }\n    }\n    return l;\n  }\n\n  /**\n   * @param {number} lineNumber\n   * @return {number}\n   */\n  lineNumberToBytecodeOffset(lineNumber) {\n    return this._offsets[lineNumber];\n  }\n\n  /**\n   * @return {!Iterable<number>} an iterable enumerating all the non-breakable line numbers in the disassembly\n   */\n  * nonBreakableLineNumbers() {\n    let lineNumber = 0;\n    let functionIndex = 0;\n    while (lineNumber < this.lineNumbers) {\n      if (functionIndex < this._functionBodyOffsets.length) {\n        const offset = this.lineNumberToBytecodeOffset(lineNumber);\n        if (offset >= this._functionBodyOffsets[functionIndex].start) {\n          lineNumber = this.bytecodeOffsetToLineNumber(this._functionBodyOffsets[functionIndex++].end);\n          continue;\n        }\n      }\n      yield lineNumber++;\n    }\n  }\n}\n"]}