{"version":3,"file":"EventTarget.js","sourceRoot":"","sources":["../../../../../front_end/common/EventTarget.js"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B;;GAEG;AACH,mEAAmE;AACnE,MAAM,CAAC,IAAI,eAAe,CAAC;AAE3B;;GAEG;AACH,MAAM,UAAU,oBAAoB,CAAC,SAAS;IAC5C,KAAK,MAAM,SAAS,IAAI,SAAS,EAAE;QACjC,SAAS,CAAC,WAAW,CAAC,mBAAmB,CAAC,SAAS,CAAC,SAAS,EAAE,SAAS,CAAC,QAAQ,EAAE,SAAS,CAAC,UAAU,CAAC,CAAC;KAC1G;IACD,sDAAsD;IACtD,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC;AAED;;GAEG;AACH,MAAM,OAAO,WAAW;IACtB;;;;;OAKG;IACH,gBAAgB,CAAC,SAAS,EAAE,QAAQ,EAAE,UAAU;QAC9C,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACrC,CAAC;IAED;;;OAGG;IACH,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACrC,CAAC;IAED;;;;OAIG;IACH,mBAAmB,CAAC,SAAS,EAAE,QAAQ,EAAE,UAAU;QACjD,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACrC,CAAC;IAED;;;OAGG;IACH,iBAAiB,CAAC,SAAS;QACzB,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACrC,CAAC;IAED;;;OAGG;IACH,wBAAwB,CAAC,SAAS,EAAE,SAAS;IAC7C,CAAC;CACF;AAED,WAAW,CAAC,oBAAoB,GAAG,oBAAoB,CAAC;AAExD;;;;GAIG;AACH,MAAM,UAAU,SAAS,CAAC,IAAI,EAAE,MAAM,GAAG,EAAE,EAAE,MAAM,GAAG,MAAM;IAC1D,MAAM,GAAG,GAAG,IAAI,WAAW,CAAC,IAAI,EAAE,EAAC,OAAO,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,MAAM,EAAC,CAAC,CAAC;IAC7E,MAAM,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;AAC5B,CAAC;AAED;;GAEG;AACH,oEAAoE;AACpE,MAAM,CAAC,IAAI,gBAAgB,CAAC","sourcesContent":["// Copyright 2019 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * @typedef {!{eventTarget: !EventTarget, eventType: (string|symbol), thisObject: (!Object|undefined), listener: function(!EventTargetEvent):void}}\n */\n// @ts-ignore TS can't pick up that EventDescriptor is of this type\nexport let EventDescriptor;\n\n/**\n * @param {!Array<!EventDescriptor>} eventList\n */\nexport function removeEventListeners(eventList) {\n  for (const eventInfo of eventList) {\n    eventInfo.eventTarget.removeEventListener(eventInfo.eventType, eventInfo.listener, eventInfo.thisObject);\n  }\n  // Do not hold references on unused event descriptors.\n  eventList.splice(0);\n}\n\n/**\n * @interface\n */\nexport class EventTarget {\n  /**\n   * @param {symbol} eventType\n   * @param {function(!EventTargetEvent):void} listener\n   * @param {!Object=} thisObject\n   * @return {!EventDescriptor}\n   */\n  addEventListener(eventType, listener, thisObject) {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @param {string|symbol} eventType\n   * @return {!Promise<*>}\n   */\n  once(eventType) {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @param {string|symbol} eventType\n   * @param {function(!EventTargetEvent):void} listener\n   * @param {!Object=} thisObject\n   */\n  removeEventListener(eventType, listener, thisObject) {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @param {symbol} eventType\n   * @return {boolean}\n   */\n  hasEventListeners(eventType) {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @param {symbol} eventType\n   * @param {*=} eventData\n   */\n  dispatchEventToListeners(eventType, eventData) {\n  }\n}\n\nEventTarget.removeEventListeners = removeEventListeners;\n\n/**\n * @param {string} name\n * @param {*} detail\n * @param {!HTMLElement | !Window} target\n */\nexport function fireEvent(name, detail = {}, target = window) {\n  const evt = new CustomEvent(name, {bubbles: true, cancelable: true, detail});\n  target.dispatchEvent(evt);\n}\n\n/**\n * @typedef {!{data: *}}\n */\n// @ts-ignore TS can't pick up that EventTargetEvent is of this type\nexport let EventTargetEvent;\n"]}