{"version":3,"file":"HeapSnapshot.js","sourceRoot":"","sources":["../../../../../front_end/heap_snapshot_worker/HeapSnapshot.js"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as HeapSnapshotModel from '../heap_snapshot_model/heap_snapshot_model.js';\nimport * as i18n from '../i18n/i18n.js';\nimport * as Platform from '../platform/platform.js';\n\nimport {AllocationProfile} from './AllocationProfile.js';\nimport {HeapSnapshotWorkerDispatcher} from './HeapSnapshotWorkerDispatcher.js';  // eslint-disable-line no-unused-vars\n\n/**\n * @interface\n */\nexport class HeapSnapshotItem {\n  /**\n   * @return {number}\n   */\n  itemIndex() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @return {!Object}\n   */\n  serialize() {\n    throw new Error('Not implemented');\n  }\n}\n\n/**\n * @implements {HeapSnapshotItem}\n */\nexport class HeapSnapshotEdge {\n  /**\n   * @param {!HeapSnapshot} snapshot\n   * @param {number=} edgeIndex\n   */\n  constructor(snapshot, edgeIndex) {\n    this._snapshot = snapshot;\n    this._edges = snapshot.containmentEdges;\n    this.edgeIndex = edgeIndex || 0;\n  }\n\n  /**\n   * @return {!HeapSnapshotEdge}\n   */\n  clone() {\n    return new HeapSnapshotEdge(this._snapshot, this.edgeIndex);\n  }\n\n  /**\n   * @return {boolean}\n   */\n  hasStringName() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @return {string}\n   */\n  name() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @return {!HeapSnapshotNode}\n   */\n  node() {\n    return this._snapshot.createNode(this.nodeIndex());\n  }\n\n  /**\n   * @return {number}\n   */\n  nodeIndex() {\n    if (typeof this._snapshot._edgeToNodeOffset === 'undefined') {\n      throw new Error('edgeToNodeOffset is undefined');\n    }\n\n    return this._edges[this.edgeIndex + this._snapshot._edgeToNodeOffset];\n  }\n\n  /**\n   * @override\n   * @return {string}\n   */\n  toString() {\n    return 'HeapSnapshotEdge: ' + this.name();\n  }\n\n  /**\n   * @return {string}\n   */\n  type() {\n    return this._snapshot._edgeTypes[this.rawType()];\n  }\n\n  /**\n   * @override\n   * @return {number}\n   */\n  itemIndex() {\n    return this.edgeIndex;\n  }\n\n  /**\n   * @override\n   * @return {!HeapSnapshotModel.HeapSnapshotModel.Edge}\n   */\n  serialize() {\n    return new HeapSnapshotModel.HeapSnapshotModel.Edge(\n        this.name(), this.node().serialize(), this.type(), this.edgeIndex);\n  }\n\n  /**\n   * @protected\n   * @return {number}\n   */\n  rawType() {\n    if (typeof this._snapshot._edgeTypeOffset === 'undefined') {\n      throw new Error('edgeTypeOffset is undefined');\n    }\n\n    return this._edges[this.edgeIndex + this._snapshot._edgeTypeOffset];\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isInvisible() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isWeak() {\n    throw new Error('Not implemented');\n  }\n}\n\n/**\n * @interface\n */\nexport class HeapSnapshotItemIterator {\n  /**\n   * @return {boolean}\n   */\n  hasNext() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @return {!HeapSnapshotItem}\n   */\n  item() {\n    throw new Error('Not implemented');\n  }\n\n  next() {\n    throw new Error('Not implemented');\n  }\n}\n\n/**\n * @interface\n */\nexport class HeapSnapshotItemIndexProvider {\n  /**\n   * @param {number} newIndex\n   * @return {!HeapSnapshotItem}\n   */\n  itemForIndex(newIndex) {\n    throw new Error('Not implemented');\n  }\n}\n\n/**\n * @implements {HeapSnapshotItemIndexProvider}\n */\nexport class HeapSnapshotNodeIndexProvider {\n  /**\n   * @param {!HeapSnapshot} snapshot\n   */\n  constructor(snapshot) {\n    this._node = snapshot.createNode();\n  }\n\n  /**\n   * @override\n   * @param {number} index\n   * @return {!HeapSnapshotNode}\n   */\n  itemForIndex(index) {\n    this._node.nodeIndex = index;\n    return this._node;\n  }\n}\n\n/**\n * @implements {HeapSnapshotItemIndexProvider}\n */\nexport class HeapSnapshotEdgeIndexProvider {\n  /**\n   * @param {!HeapSnapshot} snapshot\n   */\n  constructor(snapshot) {\n    this._edge = snapshot.createEdge(0);\n  }\n\n  /**\n   * @override\n   * @param {number} index\n   * @return {!HeapSnapshotEdge}\n   */\n  itemForIndex(index) {\n    this._edge.edgeIndex = index;\n    return this._edge;\n  }\n}\n\n/**\n * @implements {HeapSnapshotItemIndexProvider}\n */\nexport class HeapSnapshotRetainerEdgeIndexProvider {\n  /**\n   * @param {!HeapSnapshot} snapshot\n   */\n  constructor(snapshot) {\n    this._retainerEdge = snapshot.createRetainingEdge(0);\n  }\n\n  /**\n   * @override\n   * @param {number} index\n   * @return {!HeapSnapshotRetainerEdge}\n   */\n  itemForIndex(index) {\n    this._retainerEdge.setRetainerIndex(index);\n    return this._retainerEdge;\n  }\n}\n\n/**\n * @implements {HeapSnapshotItemIterator}\n */\nexport class HeapSnapshotEdgeIterator {\n  /**\n   * @param {!HeapSnapshotNode} node\n   */\n  constructor(node) {\n    this._sourceNode = node;\n    this.edge = node._snapshot.createEdge(node.edgeIndexesStart());\n  }\n\n  /**\n   * @override\n   * @return {boolean}\n   */\n  hasNext() {\n    return this.edge.edgeIndex < this._sourceNode.edgeIndexesEnd();\n  }\n\n  /**\n   * @override\n   * @return {!HeapSnapshotEdge}\n   */\n  item() {\n    return this.edge;\n  }\n\n  /**\n   * @override\n   */\n  next() {\n    if (typeof this.edge._snapshot._edgeFieldsCount === 'undefined') {\n      throw new Error('edgeFieldsCount is undefined');\n    }\n    this.edge.edgeIndex += this.edge._snapshot._edgeFieldsCount;\n  }\n}\n\n/**\n * @implements {HeapSnapshotItem}\n */\nexport class HeapSnapshotRetainerEdge {\n  /**\n   * @param {!HeapSnapshot} snapshot\n   * @param {number} retainerIndex\n   */\n  constructor(snapshot, retainerIndex) {\n    this._snapshot = snapshot;\n    /**\n     * @type {number}\n     */\n    this._retainerIndex;\n\n    /**\n     * @type {number};\n     */\n    this._globalEdgeIndex;\n    this.setRetainerIndex(retainerIndex);\n  }\n\n  /**\n   * @return {!HeapSnapshotRetainerEdge}\n   */\n  clone() {\n    return new HeapSnapshotRetainerEdge(this._snapshot, this.retainerIndex());\n  }\n\n  /**\n   * @return {boolean}\n   */\n  hasStringName() {\n    return this._edge().hasStringName();\n  }\n\n  /**\n   * @return {string}\n   */\n  name() {\n    return this._edge().name();\n  }\n\n  /**\n   * @return {!HeapSnapshotNode}\n   */\n  node() {\n    return this._node();\n  }\n\n  /**\n   * @return {number}\n   */\n  nodeIndex() {\n    if (typeof this._retainingNodeIndex === 'undefined') {\n      throw new Error('retainingNodeIndex is undefined');\n    }\n\n    return this._retainingNodeIndex;\n  }\n\n  /**\n   * @return {number}\n   */\n  retainerIndex() {\n    return this._retainerIndex;\n  }\n\n  /**\n   * @param {number} retainerIndex\n   */\n  setRetainerIndex(retainerIndex) {\n    if (retainerIndex === this._retainerIndex) {\n      return;\n    }\n\n    if (!this._snapshot._retainingEdges || !this._snapshot._retainingNodes) {\n      throw new Error('Snapshot does not contain retaining edges or retaining nodes');\n    }\n\n    this._retainerIndex = retainerIndex;\n    this._globalEdgeIndex = this._snapshot._retainingEdges[retainerIndex];\n    this._retainingNodeIndex = this._snapshot._retainingNodes[retainerIndex];\n    this._edgeInstance = null;\n    this._nodeInstance = null;\n  }\n\n  /**\n   * @param {number} edgeIndex\n   */\n  set edgeIndex(edgeIndex) {\n    this.setRetainerIndex(edgeIndex);\n  }\n\n  _node() {\n    if (!this._nodeInstance) {\n      this._nodeInstance = this._snapshot.createNode(this._retainingNodeIndex);\n    }\n    return this._nodeInstance;\n  }\n\n  _edge() {\n    if (!this._edgeInstance) {\n      this._edgeInstance = this._snapshot.createEdge(this._globalEdgeIndex);\n    }\n    return this._edgeInstance;\n  }\n\n  /**\n   * @override\n   * @return {string}\n   */\n  toString() {\n    return this._edge().toString();\n  }\n\n  /**\n   * @override\n   * @return {number}\n   */\n  itemIndex() {\n    return this._retainerIndex;\n  }\n\n  /**\n   * @override\n   * @return {!HeapSnapshotModel.HeapSnapshotModel.Edge}\n   */\n  serialize() {\n    return new HeapSnapshotModel.HeapSnapshotModel.Edge(\n        this.name(), this.node().serialize(), this.type(), this._globalEdgeIndex);\n  }\n\n  /**\n   * @return {string}\n   */\n  type() {\n    return this._edge().type();\n  }\n}\n\n/**\n * @implements {HeapSnapshotItemIterator}\n */\nexport class HeapSnapshotRetainerEdgeIterator {\n  /**\n   * @param {!HeapSnapshotNode} retainedNode\n   */\n  constructor(retainedNode) {\n    const snapshot = retainedNode._snapshot;\n    const retainedNodeOrdinal = retainedNode.ordinal();\n    if (!snapshot._firstRetainerIndex) {\n      throw new Error('Snapshot does not contain firstRetainerIndex');\n    }\n    const retainerIndex = snapshot._firstRetainerIndex[retainedNodeOrdinal];\n    this._retainersEnd = snapshot._firstRetainerIndex[retainedNodeOrdinal + 1];\n    this.retainer = snapshot.createRetainingEdge(retainerIndex);\n  }\n\n  /**\n   * @override\n   * @return {boolean}\n   */\n  hasNext() {\n    return this.retainer.retainerIndex() < this._retainersEnd;\n  }\n\n  /**\n   * @override\n   * @return {!HeapSnapshotRetainerEdge}\n   */\n  item() {\n    return this.retainer;\n  }\n\n  /**\n   * @override\n   */\n  next() {\n    this.retainer.setRetainerIndex(this.retainer.retainerIndex() + 1);\n  }\n}\n\n/**\n * @implements {HeapSnapshotItem}\n */\nexport class HeapSnapshotNode {\n  /**\n   * @param {!HeapSnapshot} snapshot\n   * @param {number=} nodeIndex\n   */\n  constructor(snapshot, nodeIndex) {\n    this._snapshot = snapshot;\n    this.nodeIndex = nodeIndex || 0;\n  }\n\n  /**\n   * @return {number}\n   */\n  distance() {\n    return this._snapshot._nodeDistances[this.nodeIndex / this._snapshot._nodeFieldCount];\n  }\n\n  /**\n   * @return {string}\n   */\n  className() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @return {number}\n   */\n  classIndex() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @return {number}\n   */\n  dominatorIndex() {\n    const nodeFieldCount = this._snapshot._nodeFieldCount;\n    return this._snapshot._dominatorsTree[this.nodeIndex / this._snapshot._nodeFieldCount] * nodeFieldCount;\n  }\n\n  /**\n   * @return {!HeapSnapshotEdgeIterator}\n   */\n  edges() {\n    return new HeapSnapshotEdgeIterator(this);\n  }\n\n  /**\n   * @return {number}\n   */\n  edgesCount() {\n    return (this.edgeIndexesEnd() - this.edgeIndexesStart()) / this._snapshot._edgeFieldsCount;\n  }\n\n  /**\n   * @return {number}\n   */\n  id() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @return {string}\n   */\n  rawName() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isRoot() {\n    return this.nodeIndex === this._snapshot._rootNodeIndex;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isUserRoot() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isHidden() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isArray() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isDocumentDOMTreesRoot() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @return {string}\n   */\n  name() {\n    return this._snapshot.strings[this._name()];\n  }\n\n  /**\n   * @return {number}\n   */\n  retainedSize() {\n    return this._snapshot._retainedSizes[this.ordinal()];\n  }\n\n  /**\n   * @return {!HeapSnapshotRetainerEdgeIterator}\n   */\n  retainers() {\n    return new HeapSnapshotRetainerEdgeIterator(this);\n  }\n\n  /**\n   * @return {number}\n   */\n  retainersCount() {\n    const snapshot = this._snapshot;\n    const ordinal = this.ordinal();\n    return snapshot._firstRetainerIndex[ordinal + 1] - snapshot._firstRetainerIndex[ordinal];\n  }\n\n  /**\n   * @return {number}\n   */\n  selfSize() {\n    const snapshot = this._snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot._nodeSelfSizeOffset];\n  }\n\n  /**\n   * @return {string}\n   */\n  type() {\n    return this._snapshot._nodeTypes[this.rawType()];\n  }\n\n  /**\n   * @return {number}\n   */\n  traceNodeId() {\n    const snapshot = this._snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot._nodeTraceNodeIdOffset];\n  }\n\n  /**\n   * @override\n   * @return {number}\n   */\n  itemIndex() {\n    return this.nodeIndex;\n  }\n\n  /**\n   * @override\n   * @return {!HeapSnapshotModel.HeapSnapshotModel.Node}\n   */\n  serialize() {\n    return new HeapSnapshotModel.HeapSnapshotModel.Node(\n        this.id(), this.name(), this.distance(), this.nodeIndex, this.retainedSize(), this.selfSize(), this.type());\n  }\n\n  /**\n   * @return {number}\n   */\n  _name() {\n    const snapshot = this._snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot._nodeNameOffset];\n  }\n\n  /**\n   * @return {number}\n   */\n  edgeIndexesStart() {\n    return this._snapshot._firstEdgeIndexes[this.ordinal()];\n  }\n\n  /**\n   * @return {number}\n   */\n  edgeIndexesEnd() {\n    return this._snapshot._firstEdgeIndexes[this.ordinal() + 1];\n  }\n\n  /**\n   * @return {number}\n   */\n  ordinal() {\n    return this.nodeIndex / this._snapshot._nodeFieldCount;\n  }\n\n  /**\n   * @return {number}\n   */\n  _nextNodeIndex() {\n    return this.nodeIndex + this._snapshot._nodeFieldCount;\n  }\n\n  /**\n   * @protected\n   * @return {number}\n   */\n  rawType() {\n    const snapshot = this._snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot._nodeTypeOffset];\n  }\n}\n\n/**\n * @implements {HeapSnapshotItemIterator}\n */\nexport class HeapSnapshotNodeIterator {\n  /**\n   * @param {!HeapSnapshotNode} node\n   */\n  constructor(node) {\n    this.node = node;\n    this._nodesLength = node._snapshot.nodes.length;\n  }\n\n  /**\n   * @override\n   * @return {boolean}\n   */\n  hasNext() {\n    return this.node.nodeIndex < this._nodesLength;\n  }\n\n  /**\n   * @override\n   * @return {!HeapSnapshotNode}\n   */\n  item() {\n    return this.node;\n  }\n\n  /**\n   * @override\n   */\n  next() {\n    this.node.nodeIndex = this.node._nextNodeIndex();\n  }\n}\n\n/**\n * @implements {HeapSnapshotItemIterator}\n */\nexport class HeapSnapshotIndexRangeIterator {\n  /**\n   * @param {!HeapSnapshotItemIndexProvider} itemProvider\n   * @param {!Array.<number>|!Uint32Array} indexes\n   */\n  constructor(itemProvider, indexes) {\n    this._itemProvider = itemProvider;\n    this._indexes = indexes;\n    this._position = 0;\n  }\n\n  /**\n   * @override\n   * @return {boolean}\n   */\n  hasNext() {\n    return this._position < this._indexes.length;\n  }\n\n  /**\n   * @override\n   * @return {!HeapSnapshotItem}\n   */\n  item() {\n    const index = this._indexes[this._position];\n    return this._itemProvider.itemForIndex(index);\n  }\n\n  /**\n   * @override\n   */\n  next() {\n    ++this._position;\n  }\n}\n\n/**\n * @implements {HeapSnapshotItemIterator}\n */\nexport class HeapSnapshotFilteredIterator {\n  /**\n   * @param {!HeapSnapshotItemIterator} iterator\n   * @param {function(!HeapSnapshotItem):boolean=} filter\n   */\n  constructor(iterator, filter) {\n    this._iterator = iterator;\n    this._filter = filter;\n    this._skipFilteredItems();\n  }\n\n  /**\n   * @override\n   * @return {boolean}\n   */\n  hasNext() {\n    return this._iterator.hasNext();\n  }\n\n  /**\n   * @override\n   * @return {!HeapSnapshotItem}\n   */\n  item() {\n    return this._iterator.item();\n  }\n\n  /**\n   * @override\n   */\n  next() {\n    this._iterator.next();\n    this._skipFilteredItems();\n  }\n\n  _skipFilteredItems() {\n    while (this._iterator.hasNext() && this._filter && !this._filter(this._iterator.item())) {\n      this._iterator.next();\n    }\n  }\n}\n\nexport class HeapSnapshotProgress {\n  /**\n   * @param {!HeapSnapshotWorkerDispatcher=} dispatcher\n   */\n  constructor(dispatcher) {\n    this._dispatcher = dispatcher;\n  }\n\n  /**\n   * @param {string} status\n   */\n  updateStatus(status) {\n    this._sendUpdateEvent(i18n.i18n.serializeUIString(status));\n  }\n\n  /**\n   * @param {string} title\n   * @param {number} value\n   * @param {number} total\n   */\n  updateProgress(title, value, total) {\n    const percentValue = ((total ? (value / total) : 0) * 100).toFixed(0);\n    this._sendUpdateEvent(i18n.i18n.serializeUIString(title, {PH1: percentValue}));\n  }\n\n  /**\n   * @param {string} error\n   */\n  reportProblem(error) {\n    // May be undefined in tests.\n    if (this._dispatcher) {\n      this._dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.BrokenSnapshot, error);\n    }\n  }\n\n  /**\n   * @param {string} serializedText\n   */\n  _sendUpdateEvent(serializedText) {\n    // May be undefined in tests.\n    if (this._dispatcher) {\n      this._dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.Update, serializedText);\n    }\n  }\n}\n\nexport class HeapSnapshotProblemReport {\n  /**\n   * @param {string} title\n   */\n  constructor(title) {\n    this._errors = [title];\n  }\n\n  /**\n   * @param {string} error\n   */\n  addError(error) {\n    if (this._errors.length > 100) {\n      return;\n    }\n    this._errors.push(error);\n  }\n\n  /**\n   * @override\n   * @return {string}\n   */\n  toString() {\n    return this._errors.join('\\n  ');\n  }\n}\n\n/** @typedef {{\n * root_index: number,\n * nodes: !Uint32Array,\n * edges: !Uint32Array,\n * snapshot: !HeapSnapshotHeader,\n * samples: !Array<number>,\n * strings: !Array<string>,\n * locations: !Array<number>,\n * trace_function_infos: !Uint32Array,\n * trace_tree: Object\n * }} */\n/* @ts-ignore-next Type def */\nexport let Profile;\n\n/**\n * DOM node link state.\n *\n * @enum {number}\n */\nconst DOMLinkState = {\n  /** @type {number} */\n  'Unknown': 0,\n  /** @type {number} */\n  'Attached': 1,\n  /** @type {number} */\n  'Detached': 2\n};\nObject.freeze(DOMLinkState);\n\nexport class HeapSnapshot {\n  /**\n   * @param {!Profile} profile\n   * @param {!HeapSnapshotProgress} progress\n   */\n  constructor(profile, progress) {\n    /** @type {!Uint32Array} */\n    this.nodes = profile.nodes;\n    /** @type {!Uint32Array} */\n    this.containmentEdges = profile.edges;\n    /** @type {!HeapSnapshotMetainfo} */\n    this._metaNode = profile.snapshot.meta;\n    /** @type {!Array.<number>} */\n    this._rawSamples = profile.samples;\n    /** @type {?HeapSnapshotModel.HeapSnapshotModel.Samples} */\n    this._samples = null;\n    /** @type {!Array.<string>} */\n    this.strings = profile.strings;\n    /** @type {!Array.<number>} */\n    this._locations = profile.locations;\n    this._progress = progress;\n\n    this._noDistance = -5;\n    this._rootNodeIndex = 0;\n    if (profile.snapshot.root_index) {\n      this._rootNodeIndex = profile.snapshot.root_index;\n    }\n\n    /**\n     * @type {!Object.<string, !Object.<string, !HeapSnapshotModel.HeapSnapshotModel.Diff>>}\n     */\n    this._snapshotDiffs = {};\n\n    /**\n     * @type {!Object.<string, !HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff>}\n     */\n    this._aggregatesForDiff;\n\n    /**\n     * @type {!Object.<string, !Object.<string, !AggregatedInfo>>}\n     */\n    this._aggregates = {};\n\n    /**\n     * @type {!Object.<string, boolean>}\n     */\n    this._aggregatesSortedFlags = {};\n    this._profile = profile;\n\n    /**\n     * @type {number}\n     */\n    this._nodeTypeOffset;\n\n    /**\n     * @type {number}\n     */\n    this._nodeNameOffset;\n\n    /**\n     * @type {number}\n     */\n    this._nodeIdOffset;\n\n    /**\n     * @type {number}\n     */\n    this._nodeSelfSizeOffset;\n\n    /**\n     * @type {number}\n     */\n    this._nodeEdgeCountOffset;\n\n    /**\n     * @type {number}\n     */\n    this._nodeTraceNodeIdOffset;\n\n    /**\n     * @type {number}\n     */\n    this._nodeFieldCount;\n\n    /**\n     * @type {!Array<string>}\n     */\n    this._nodeTypes;\n\n    /**\n     * @type {number}\n     */\n    this._nodeArrayType;\n\n    /**\n     * @type {number}\n     */\n    this._nodeHiddenType;\n\n    /**\n     * @type {number}\n     */\n    this._nodeObjectType;\n\n    /**\n     * @type {number}\n     */\n    this._nodeNativeType;\n\n    /**\n     * @type {number}\n     */\n    this._nodeConsStringType;\n\n    /**\n     * @type {number}\n     */\n    this._nodeSlicedStringType;\n\n    /**\n     * @type {number}\n     */\n    this._nodeCodeType;\n\n    /**\n     * @type {number}\n     */\n    this._nodeSyntheticType;\n\n    /**\n     * @type {number}\n     */\n    this._edgeFieldsCount;\n\n    /**\n     * @type {number}\n     */\n    this._edgeTypeOffset;\n\n    /**\n     * @type {number}\n     */\n    this._edgeNameOffset;\n\n    /**\n     * @type {number}\n     */\n    this._edgeToNodeOffset;\n\n    /**\n     * @type {!Array<string>}\n     */\n    this._edgeTypes;\n\n    /**\n     * @type {number}\n     */\n    this._edgeElementType;\n\n    /**\n     * @type {number}\n     */\n    this._edgeHiddenType;\n\n    /**\n     * @type {number}\n     */\n    this._edgeInternalType;\n\n    /**\n     * @type {number}\n     */\n    this._edgeShortcutType;\n\n    /**\n     * @type {number}\n     */\n    this._edgeWeakType;\n\n    /**\n     * @type {number}\n     */\n    this._edgeInvisibleType;\n\n    /**\n     * @type {number}\n     */\n    this._locationIndexOffset;\n\n    /**\n     * @type {number}\n     */\n    this._locationScriptIdOffset;\n\n    /**\n     * @type {number}\n     */\n    this._locationLineOffset;\n\n    /**\n     * @type {number}\n     */\n    this._locationColumnOffset;\n\n    /**\n     * @type {number}\n     */\n    this._locationFieldCount;\n\n    /**\n     * @type {number}\n     */\n    this.nodeCount;\n\n    /**\n     * @type {number}\n     */\n    this._edgeCount;\n\n    /**\n     * @type {!Float64Array}\n     */\n    this._retainedSizes;\n\n    /**\n     * @type {!Uint32Array}\n     */\n    this._firstEdgeIndexes;\n\n    /**\n     * @type {!Uint32Array}\n     */\n    this._retainingNodes;\n\n    /**\n     * @type {!Uint32Array}\n     */\n    this._retainingEdges;\n\n    /**\n     * @type {!Uint32Array}\n     */\n    this._firstRetainerIndex;\n\n    /**\n     * @type {!Int32Array}\n     */\n    this._nodeDistances;\n\n    /**\n     * @type {!Uint32Array}\n     */\n    this._firstDominatedNodeIndex;\n\n    /**\n     * @type {!Uint32Array}\n     */\n    this._dominatedNodes;\n\n    /**\n     * @type {!Uint32Array}\n     */\n    this._dominatorsTree;\n\n    /**\n     * @type {!AllocationProfile}\n     */\n    this._allocationProfile;\n\n    /**\n     * @type {number}\n     */\n    this._nodeDetachednessOffset;\n\n    /**\n     * @type {!Map<number, !HeapSnapshotModel.HeapSnapshotModel.Location>}\n     */\n    this._locationMap;\n\n    /**\n     * @type {!Object.<string, string>}\n     */\n    this._lazyStringCache;\n  }\n\n  /**\n   * @protected\n   */\n  initialize() {\n    const meta = this._metaNode;\n\n    this._nodeTypeOffset = meta.node_fields.indexOf('type');\n    this._nodeNameOffset = meta.node_fields.indexOf('name');\n    this._nodeIdOffset = meta.node_fields.indexOf('id');\n    this._nodeSelfSizeOffset = meta.node_fields.indexOf('self_size');\n    this._nodeEdgeCountOffset = meta.node_fields.indexOf('edge_count');\n    this._nodeTraceNodeIdOffset = meta.node_fields.indexOf('trace_node_id');\n    this._nodeDetachednessOffset = meta.node_fields.indexOf('detachedness');\n    this._nodeFieldCount = meta.node_fields.length;\n\n    this._nodeTypes = meta.node_types[this._nodeTypeOffset];\n    this._nodeArrayType = this._nodeTypes.indexOf('array');\n    this._nodeHiddenType = this._nodeTypes.indexOf('hidden');\n    this._nodeObjectType = this._nodeTypes.indexOf('object');\n    this._nodeNativeType = this._nodeTypes.indexOf('native');\n    this._nodeConsStringType = this._nodeTypes.indexOf('concatenated string');\n    this._nodeSlicedStringType = this._nodeTypes.indexOf('sliced string');\n    this._nodeCodeType = this._nodeTypes.indexOf('code');\n    this._nodeSyntheticType = this._nodeTypes.indexOf('synthetic');\n\n    this._edgeFieldsCount = meta.edge_fields.length;\n    this._edgeTypeOffset = meta.edge_fields.indexOf('type');\n    this._edgeNameOffset = meta.edge_fields.indexOf('name_or_index');\n    this._edgeToNodeOffset = meta.edge_fields.indexOf('to_node');\n\n    this._edgeTypes = meta.edge_types[this._edgeTypeOffset];\n    this._edgeTypes.push('invisible');\n    this._edgeElementType = this._edgeTypes.indexOf('element');\n    this._edgeHiddenType = this._edgeTypes.indexOf('hidden');\n    this._edgeInternalType = this._edgeTypes.indexOf('internal');\n    this._edgeShortcutType = this._edgeTypes.indexOf('shortcut');\n    this._edgeWeakType = this._edgeTypes.indexOf('weak');\n    this._edgeInvisibleType = this._edgeTypes.indexOf('invisible');\n\n    const location_fields = meta.location_fields || [];\n\n    this._locationIndexOffset = location_fields.indexOf('object_index');\n    this._locationScriptIdOffset = location_fields.indexOf('script_id');\n    this._locationLineOffset = location_fields.indexOf('line');\n    this._locationColumnOffset = location_fields.indexOf('column');\n    this._locationFieldCount = location_fields.length;\n\n    this.nodeCount = this.nodes.length / this._nodeFieldCount;\n    this._edgeCount = this.containmentEdges.length / this._edgeFieldsCount;\n\n    this._retainedSizes = new Float64Array(this.nodeCount);\n    this._firstEdgeIndexes = new Uint32Array(this.nodeCount + 1);\n    this._retainingNodes = new Uint32Array(this._edgeCount);\n    this._retainingEdges = new Uint32Array(this._edgeCount);\n    this._firstRetainerIndex = new Uint32Array(this.nodeCount + 1);\n    this._nodeDistances = new Int32Array(this.nodeCount);\n    this._firstDominatedNodeIndex = new Uint32Array(this.nodeCount + 1);\n    this._dominatedNodes = new Uint32Array(this.nodeCount - 1);\n\n    this._progress.updateStatus('Building edge indexes');\n    this._buildEdgeIndexes();\n    this._progress.updateStatus('Building retainers');\n    this._buildRetainers();\n    this._progress.updateStatus('Propagating DOM state');\n    this._propagateDOMState();\n    this._progress.updateStatus('Calculating node flags');\n    this.calculateFlags();\n    this._progress.updateStatus('Calculating distances');\n    this.calculateDistances();\n    this._progress.updateStatus('Building postorder index');\n    const result = this._buildPostOrderIndex();\n    // Actually it is array that maps node ordinal number to dominator node ordinal number.\n    this._progress.updateStatus('Building dominator tree');\n    this._dominatorsTree =\n        this._buildDominatorTree(result.postOrderIndex2NodeOrdinal, result.nodeOrdinal2PostOrderIndex);\n    this._progress.updateStatus('Calculating retained sizes');\n    this._calculateRetainedSizes(result.postOrderIndex2NodeOrdinal);\n    this._progress.updateStatus('Building dominated nodes');\n    this._buildDominatedNodes();\n    this._progress.updateStatus('Calculating statistics');\n    this.calculateStatistics();\n    this._progress.updateStatus('Calculating samples');\n    this._buildSamples();\n    this._progress.updateStatus('Building locations');\n    this._buildLocationMap();\n    this._progress.updateStatus('Finished processing.');\n\n    if (this._profile.snapshot.trace_function_count) {\n      this._progress.updateStatus('Building allocation statistics');\n      const nodes = this.nodes;\n      const nodesLength = nodes.length;\n      const nodeFieldCount = this._nodeFieldCount;\n      const node = this.rootNode();\n      /**\n       * @type {!Object.<number, {count: number, size: number, ids: !Array<number>}>}\n       */\n      const liveObjects = {};\n      for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n        node.nodeIndex = nodeIndex;\n        const traceNodeId = node.traceNodeId();\n        let stats = liveObjects[traceNodeId];\n        if (!stats) {\n          liveObjects[traceNodeId] = stats = {count: 0, size: 0, ids: []};\n        }\n        stats.count++;\n        stats.size += node.selfSize();\n        stats.ids.push(node.id());\n      }\n      this._allocationProfile = new AllocationProfile(this._profile, liveObjects);\n      this._progress.updateStatus('done');\n    }\n  }\n\n  _buildEdgeIndexes() {\n    const nodes = this.nodes;\n    const nodeCount = this.nodeCount;\n    const firstEdgeIndexes = this._firstEdgeIndexes;\n    const nodeFieldCount = this._nodeFieldCount;\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const nodeEdgeCountOffset = this._nodeEdgeCountOffset;\n    firstEdgeIndexes[nodeCount] = this.containmentEdges.length;\n    for (let nodeOrdinal = 0, edgeIndex = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      firstEdgeIndexes[nodeOrdinal] = edgeIndex;\n      edgeIndex += nodes[nodeOrdinal * nodeFieldCount + nodeEdgeCountOffset] * edgeFieldsCount;\n    }\n  }\n\n  _buildRetainers() {\n    const retainingNodes = this._retainingNodes;\n    const retainingEdges = this._retainingEdges;\n    // Index of the first retainer in the _retainingNodes and _retainingEdges\n    // arrays. Addressed by retained node index.\n    const firstRetainerIndex = this._firstRetainerIndex;\n\n    const containmentEdges = this.containmentEdges;\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const nodeFieldCount = this._nodeFieldCount;\n    const edgeToNodeOffset = this._edgeToNodeOffset;\n    const firstEdgeIndexes = this._firstEdgeIndexes;\n    const nodeCount = this.nodeCount;\n\n    for (let toNodeFieldIndex = edgeToNodeOffset, l = containmentEdges.length; toNodeFieldIndex < l;\n         toNodeFieldIndex += edgeFieldsCount) {\n      const toNodeIndex = containmentEdges[toNodeFieldIndex];\n      if (toNodeIndex % nodeFieldCount) {\n        throw new Error('Invalid toNodeIndex ' + toNodeIndex);\n      }\n      ++firstRetainerIndex[toNodeIndex / nodeFieldCount];\n    }\n    for (let i = 0, firstUnusedRetainerSlot = 0; i < nodeCount; i++) {\n      const retainersCount = firstRetainerIndex[i];\n      firstRetainerIndex[i] = firstUnusedRetainerSlot;\n      retainingNodes[firstUnusedRetainerSlot] = retainersCount;\n      firstUnusedRetainerSlot += retainersCount;\n    }\n    firstRetainerIndex[nodeCount] = retainingNodes.length;\n\n    let nextNodeFirstEdgeIndex = firstEdgeIndexes[0];\n    for (let srcNodeOrdinal = 0; srcNodeOrdinal < nodeCount; ++srcNodeOrdinal) {\n      const firstEdgeIndex = nextNodeFirstEdgeIndex;\n      nextNodeFirstEdgeIndex = firstEdgeIndexes[srcNodeOrdinal + 1];\n      const srcNodeIndex = srcNodeOrdinal * nodeFieldCount;\n      for (let edgeIndex = firstEdgeIndex; edgeIndex < nextNodeFirstEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const toNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n        if (toNodeIndex % nodeFieldCount) {\n          throw new Error('Invalid toNodeIndex ' + toNodeIndex);\n        }\n        const firstRetainerSlotIndex = firstRetainerIndex[toNodeIndex / nodeFieldCount];\n        const nextUnusedRetainerSlotIndex = firstRetainerSlotIndex + (--retainingNodes[firstRetainerSlotIndex]);\n        retainingNodes[nextUnusedRetainerSlotIndex] = srcNodeIndex;\n        retainingEdges[nextUnusedRetainerSlotIndex] = edgeIndex;\n      }\n    }\n  }\n\n  /**\n   * @param {number=} nodeIndex\n   * @return {!HeapSnapshotNode}\n   */\n  createNode(nodeIndex) {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param {number} edgeIndex\n   * @return {!JSHeapSnapshotEdge}\n   */\n  createEdge(edgeIndex) {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param {number} retainerIndex\n   * @return {!JSHeapSnapshotRetainerEdge}\n   */\n  createRetainingEdge(retainerIndex) {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @return {!HeapSnapshotNodeIterator}\n   */\n  _allNodes() {\n    return new HeapSnapshotNodeIterator(this.rootNode());\n  }\n\n  /**\n   * @return {!HeapSnapshotNode}\n   */\n  rootNode() {\n    return this.createNode(this._rootNodeIndex);\n  }\n\n  /**\n   * @return {number}\n   */\n  get rootNodeIndex() {\n    return this._rootNodeIndex;\n  }\n\n  /**\n   * @return {number}\n   */\n  get totalSize() {\n    return this.rootNode().retainedSize();\n  }\n\n  /**\n   * @param {number} nodeIndex\n   * @return {number}\n   */\n  _getDominatedIndex(nodeIndex) {\n    if (nodeIndex % this._nodeFieldCount) {\n      throw new Error('Invalid nodeIndex: ' + nodeIndex);\n    }\n    return this._firstDominatedNodeIndex[nodeIndex / this._nodeFieldCount];\n  }\n\n  /**\n   * @param {!HeapSnapshotModel.HeapSnapshotModel.NodeFilter} nodeFilter\n   * @return {undefined|function(!HeapSnapshotNode):boolean}\n   */\n  _createFilter(nodeFilter) {\n    const minNodeId = nodeFilter.minNodeId;\n    const maxNodeId = nodeFilter.maxNodeId;\n    const allocationNodeId = nodeFilter.allocationNodeId;\n    let filter;\n    if (typeof allocationNodeId === 'number') {\n      filter = this._createAllocationStackFilter(allocationNodeId);\n      if (!filter) {\n        throw new Error('Unable to create filter');\n      }\n      // @ts-ignore key can be added as a static property\n      filter.key = 'AllocationNodeId: ' + allocationNodeId;\n    } else if (typeof minNodeId === 'number' && typeof maxNodeId === 'number') {\n      filter = this._createNodeIdFilter(minNodeId, maxNodeId);\n      // @ts-ignore key can be added as a static property\n      filter.key = 'NodeIdRange: ' + minNodeId + '..' + maxNodeId;\n    }\n    return filter;\n  }\n\n  /**\n   * @param {!HeapSnapshotModel.HeapSnapshotModel.SearchConfig} searchConfig\n   * @param {!HeapSnapshotModel.HeapSnapshotModel.NodeFilter} nodeFilter\n   * @return {!Array.<number>}\n   */\n  search(searchConfig, nodeFilter) {\n    const query = searchConfig.query;\n\n    /**\n     * @param {!Set<number>} matchedStringIndexes\n     * @param {string} string\n     * @param {number} index\n     */\n    function filterString(matchedStringIndexes, string, index) {\n      if (string.indexOf(query) !== -1) {\n        matchedStringIndexes.add(index);\n      }\n      return matchedStringIndexes;\n    }\n\n    const regexp = searchConfig.isRegex ? new RegExp(query) : createPlainTextSearchRegex(query, 'i');\n\n    /**\n     * @param {!Set<number>} matchedStringIndexes\n     * @param {string} string\n     * @param {number} index\n     */\n    function filterRegexp(matchedStringIndexes, string, index) {\n      if (regexp.test(string)) {\n        matchedStringIndexes.add(index);\n      }\n      return matchedStringIndexes;\n    }\n\n    const stringFilter = (searchConfig.isRegex || !searchConfig.caseSensitive) ? filterRegexp : filterString;\n    const stringIndexes = this.strings.reduce(stringFilter, new Set());\n\n    if (!stringIndexes.size) {\n      return [];\n    }\n\n    const filter = this._createFilter(nodeFilter);\n    const nodeIds = [];\n    const nodesLength = this.nodes.length;\n    const nodes = this.nodes;\n    const nodeNameOffset = this._nodeNameOffset;\n    const nodeIdOffset = this._nodeIdOffset;\n    const nodeFieldCount = this._nodeFieldCount;\n    const node = this.rootNode();\n\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      if (filter && !filter(node)) {\n        continue;\n      }\n      if (stringIndexes.has(nodes[nodeIndex + nodeNameOffset])) {\n        nodeIds.push(nodes[nodeIndex + nodeIdOffset]);\n      }\n    }\n    return nodeIds;\n  }\n\n  /**\n   * @param {!HeapSnapshotModel.HeapSnapshotModel.NodeFilter} nodeFilter\n   * @return {!Object.<string, !HeapSnapshotModel.HeapSnapshotModel.Aggregate>}\n   */\n  aggregatesWithFilter(nodeFilter) {\n    const filter = this._createFilter(nodeFilter);\n    // @ts-ignore key is added in _createFilter\n    const key = filter ? filter.key : 'allObjects';\n    return this.aggregates(false, key, filter);\n  }\n\n  /**\n   * @param {number} minNodeId\n   * @param {number} maxNodeId\n   * @return {function(!HeapSnapshotNode):boolean}\n   */\n  _createNodeIdFilter(minNodeId, maxNodeId) {\n    /**\n     * @param {!HeapSnapshotNode} node\n     * @return {boolean}\n     */\n    function nodeIdFilter(node) {\n      const id = node.id();\n      return id > minNodeId && id <= maxNodeId;\n    }\n    return nodeIdFilter;\n  }\n\n  /**\n   * @param {number} bottomUpAllocationNodeId\n   * @return {undefined|function(!HeapSnapshotNode):boolean}\n   */\n  _createAllocationStackFilter(bottomUpAllocationNodeId) {\n    if (!this._allocationProfile) {\n      throw new Error('No Allocation Profile provided');\n    }\n\n    const traceIds = this._allocationProfile.traceIds(bottomUpAllocationNodeId);\n    if (!traceIds.length) {\n      return undefined;\n    }\n\n    /**\n     * @type {!Object<number, boolean>}\n     */\n    const set = {};\n    for (let i = 0; i < traceIds.length; i++) {\n      set[traceIds[i]] = true;\n    }\n    /**\n     * @param {!HeapSnapshotNode} node\n     * @return {boolean}\n     */\n    function traceIdFilter(node) {\n      return Boolean(set[node.traceNodeId()]);\n    }\n    return traceIdFilter;\n  }\n\n  /**\n   * @param {boolean} sortedIndexes\n   * @param {string=} key\n   * @param {function(!HeapSnapshotNode):boolean=} filter\n   * @return {!Object.<string, !HeapSnapshotModel.HeapSnapshotModel.Aggregate>}\n   */\n  aggregates(sortedIndexes, key, filter) {\n    const aggregates = this._buildAggregates(filter);\n\n    let aggregatesByClassName;\n    if (key && this._aggregates[key]) {\n      aggregatesByClassName = this._aggregates[key];\n    } else {\n      this._calculateClassesRetainedSize(aggregates.aggregatesByClassIndex, filter);\n      aggregatesByClassName = aggregates.aggregatesByClassName;\n      if (key) {\n        this._aggregates[key] = aggregatesByClassName;\n      }\n    }\n\n    if (sortedIndexes && (!key || !this._aggregatesSortedFlags[key])) {\n      this._sortAggregateIndexes(aggregates.aggregatesByClassName);\n      if (key) {\n        this._aggregatesSortedFlags[key] = sortedIndexes;\n      }\n    }\n\n    return /** @type {!Object.<string, !HeapSnapshotModel.HeapSnapshotModel.Aggregate>} */ (aggregatesByClassName);\n  }\n\n  /**\n   * @return {!Array.<!HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode>}\n   */\n  allocationTracesTops() {\n    return this._allocationProfile.serializeTraceTops();\n  }\n\n  /**\n   * @param {number} nodeId\n   * @return {!HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers}\n   */\n  allocationNodeCallers(nodeId) {\n    return this._allocationProfile.serializeCallers(nodeId);\n  }\n\n  /**\n   * @param {number} nodeIndex\n   * @return {?Array.<!HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame>}\n   */\n  allocationStack(nodeIndex) {\n    const node = this.createNode(nodeIndex);\n    const allocationNodeId = node.traceNodeId();\n    if (!allocationNodeId) {\n      return null;\n    }\n    return this._allocationProfile.serializeAllocationStack(allocationNodeId);\n  }\n\n  /**\n   * @return {!Object.<string, !HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff>}\n   */\n  aggregatesForDiff() {\n    if (this._aggregatesForDiff) {\n      return this._aggregatesForDiff;\n    }\n\n    const aggregatesByClassName = this.aggregates(true, 'allObjects');\n    this._aggregatesForDiff = {};\n\n    const node = this.createNode();\n    for (const className in aggregatesByClassName) {\n      const aggregate = aggregatesByClassName[className];\n      const indexes = aggregate.idxs;\n      const ids = new Array(indexes.length);\n      const selfSizes = new Array(indexes.length);\n      for (let i = 0; i < indexes.length; i++) {\n        node.nodeIndex = indexes[i];\n        ids[i] = node.id();\n        selfSizes[i] = node.selfSize();\n      }\n\n      this._aggregatesForDiff[className] = {indexes: indexes, ids: ids, selfSizes: selfSizes};\n    }\n    return this._aggregatesForDiff;\n  }\n\n  /**\n   * @protected\n   * @param {!HeapSnapshotNode} node\n   * @return {boolean}\n   */\n  isUserRoot(node) {\n    return true;\n  }\n\n  /**\n   * @param {function(!HeapSnapshotNode,!HeapSnapshotEdge):boolean=} filter\n   */\n  calculateDistances(filter) {\n    const nodeCount = this.nodeCount;\n    const distances = this._nodeDistances;\n    const noDistance = this._noDistance;\n    for (let i = 0; i < nodeCount; ++i) {\n      distances[i] = noDistance;\n    }\n\n    const nodesToVisit = new Uint32Array(this.nodeCount);\n    let nodesToVisitLength = 0;\n\n    // BFS for user root objects.\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      const node = iter.edge.node();\n      if (this.isUserRoot(node)) {\n        distances[node.ordinal()] = 1;\n        nodesToVisit[nodesToVisitLength++] = node.nodeIndex;\n      }\n    }\n    this._bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n\n    // BFS for objects not reached from user roots.\n    distances[this.rootNode().ordinal()] =\n        nodesToVisitLength > 0 ? HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance : 0;\n    nodesToVisit[0] = this.rootNode().nodeIndex;\n    nodesToVisitLength = 1;\n    this._bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n  }\n\n  /**\n   * @param {!Uint32Array} nodesToVisit\n   * @param {number} nodesToVisitLength\n   * @param {!Int32Array} distances\n   * @param {function(!HeapSnapshotNode,!HeapSnapshotEdge):boolean=} filter\n   */\n  _bfs(nodesToVisit, nodesToVisitLength, distances, filter) {\n    // Preload fields into local variables for better performance.\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const nodeFieldCount = this._nodeFieldCount;\n    const containmentEdges = this.containmentEdges;\n    const firstEdgeIndexes = this._firstEdgeIndexes;\n    const edgeToNodeOffset = this._edgeToNodeOffset;\n    const edgeTypeOffset = this._edgeTypeOffset;\n    const nodeCount = this.nodeCount;\n    const edgeWeakType = this._edgeWeakType;\n    const noDistance = this._noDistance;\n\n    let index = 0;\n    const edge = this.createEdge(0);\n    const node = this.createNode(0);\n    while (index < nodesToVisitLength) {\n      const nodeIndex = nodesToVisit[index++];  // shift generates too much garbage.\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const distance = distances[nodeOrdinal] + 1;\n      const firstEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const edgesEnd = firstEdgeIndexes[nodeOrdinal + 1];\n      node.nodeIndex = nodeIndex;\n      for (let edgeIndex = firstEdgeIndex; edgeIndex < edgesEnd; edgeIndex += edgeFieldsCount) {\n        const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n        if (edgeType === edgeWeakType) {\n          continue;\n        }\n        const childNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (distances[childNodeOrdinal] !== noDistance) {\n          continue;\n        }\n        edge.edgeIndex = edgeIndex;\n        if (filter && !filter(node, edge)) {\n          continue;\n        }\n        distances[childNodeOrdinal] = distance;\n        nodesToVisit[nodesToVisitLength++] = childNodeIndex;\n      }\n    }\n    if (nodesToVisitLength > nodeCount) {\n      throw new Error(\n          'BFS failed. Nodes to visit (' + nodesToVisitLength + ') is more than nodes count (' + nodeCount + ')');\n    }\n  }\n\n  /**\n   * @param {function(!HeapSnapshotNode):boolean=} filter\n   * @return {!{aggregatesByClassName: !Object<string, !AggregatedInfo>,\n   *     aggregatesByClassIndex: !Object<number, !AggregatedInfo>}}\n   */\n  _buildAggregates(filter) {\n    /**\n     * @type {!Object.<number, !AggregatedInfo>}\n     */\n    const aggregates = {};\n\n    /**\n     * @type {!Object.<string, !AggregatedInfo>}\n     */\n    const aggregatesByClassName = {};\n\n    const classIndexes = [];\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeNativeType = this._nodeNativeType;\n    const nodeFieldCount = this._nodeFieldCount;\n    const selfSizeOffset = this._nodeSelfSizeOffset;\n    const nodeTypeOffset = this._nodeTypeOffset;\n    const node = this.rootNode();\n    const nodeDistances = this._nodeDistances;\n\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      if (filter && !filter(node)) {\n        continue;\n      }\n      const selfSize = nodes[nodeIndex + selfSizeOffset];\n      if (!selfSize && nodes[nodeIndex + nodeTypeOffset] !== nodeNativeType) {\n        continue;\n      }\n      const classIndex = node.classIndex();\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const distance = nodeDistances[nodeOrdinal];\n      if (!(classIndex in aggregates)) {\n        const nodeType = node.type();\n        const nameMatters = nodeType === 'object' || nodeType === 'native';\n        const value = {\n          count: 1,\n          distance: distance,\n          self: selfSize,\n          maxRet: 0,\n          type: nodeType,\n          name: nameMatters ? node.name() : null,\n          idxs: [nodeIndex]\n        };\n        aggregates[classIndex] = value;\n        classIndexes.push(classIndex);\n        aggregatesByClassName[node.className()] = value;\n      } else {\n        const clss = aggregates[classIndex];\n        if (!clss) {\n          continue;\n        }\n        clss.distance = Math.min(clss.distance, distance);\n        ++clss.count;\n        clss.self += selfSize;\n        clss.idxs.push(nodeIndex);\n      }\n    }\n\n    // Shave off provisionally allocated space.\n    for (let i = 0, l = classIndexes.length; i < l; ++i) {\n      const classIndex = classIndexes[i];\n      const classIndexValues = aggregates[classIndex];\n      if (!classIndexValues) {\n        continue;\n      }\n      classIndexValues.idxs = classIndexValues.idxs.slice();\n    }\n\n    return {aggregatesByClassName: aggregatesByClassName, aggregatesByClassIndex: aggregates};\n  }\n\n  /**\n   * @param {!Object<number, !AggregatedInfo>} aggregates\n   * @param {function(!HeapSnapshotNode):boolean=} filter\n   */\n  _calculateClassesRetainedSize(aggregates, filter) {\n    const rootNodeIndex = this._rootNodeIndex;\n    const node = this.createNode(rootNodeIndex);\n    const list = [rootNodeIndex];\n    const sizes = [-1];\n    const classes = [];\n\n    /**\n     * @type {!Map<number, boolean>}\n     */\n    const seenClassNameIndexes = new Map();\n    const nodeFieldCount = this._nodeFieldCount;\n    const nodeTypeOffset = this._nodeTypeOffset;\n    const nodeNativeType = this._nodeNativeType;\n    const dominatedNodes = this._dominatedNodes;\n    const nodes = this.nodes;\n    const firstDominatedNodeIndex = this._firstDominatedNodeIndex;\n\n    while (list.length) {\n      const nodeIndex = /** @type {number} */ (list.pop());\n      node.nodeIndex = nodeIndex;\n      let classIndex = node.classIndex();\n      const seen = Boolean(seenClassNameIndexes.get(classIndex));\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const dominatedIndexFrom = firstDominatedNodeIndex[nodeOrdinal];\n      const dominatedIndexTo = firstDominatedNodeIndex[nodeOrdinal + 1];\n\n      if (!seen && (!filter || filter(node)) &&\n          (node.selfSize() || nodes[nodeIndex + nodeTypeOffset] === nodeNativeType)) {\n        aggregates[classIndex].maxRet += node.retainedSize();\n        if (dominatedIndexFrom !== dominatedIndexTo) {\n          seenClassNameIndexes.set(classIndex, true);\n          sizes.push(list.length);\n          classes.push(classIndex);\n        }\n      }\n      for (let i = dominatedIndexFrom; i < dominatedIndexTo; i++) {\n        list.push(dominatedNodes[i]);\n      }\n\n      const l = list.length;\n      while (sizes[sizes.length - 1] === l) {\n        sizes.pop();\n        classIndex = /** @type {number} */ (classes.pop());\n        seenClassNameIndexes.set(classIndex, false);\n      }\n    }\n  }\n\n  /**\n   * @param {!Object<string, !AggregatedInfo>} aggregates\n   */\n  _sortAggregateIndexes(aggregates) {\n    const nodeA = this.createNode();\n    const nodeB = this.createNode();\n\n    for (const clss in aggregates) {\n      aggregates[clss].idxs.sort((idxA, idxB) => {\n        nodeA.nodeIndex = idxA;\n        nodeB.nodeIndex = idxB;\n        return nodeA.id() < nodeB.id() ? -1 : 1;\n      });\n    }\n  }\n\n  /**\n   * The function checks is the edge should be considered during building\n   * postorder iterator and dominator tree.\n   *\n   * @param {number} nodeIndex\n   * @param {number} edgeType\n   * @return {boolean}\n   */\n  _isEssentialEdge(nodeIndex, edgeType) {\n    // Shortcuts at the root node have special meaning of marking user global objects.\n    return edgeType !== this._edgeWeakType &&\n        (edgeType !== this._edgeShortcutType || nodeIndex === this._rootNodeIndex);\n  }\n\n  _buildPostOrderIndex() {\n    const nodeFieldCount = this._nodeFieldCount;\n    const nodeCount = this.nodeCount;\n    const rootNodeOrdinal = this._rootNodeIndex / nodeFieldCount;\n\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const edgeTypeOffset = this._edgeTypeOffset;\n    const edgeToNodeOffset = this._edgeToNodeOffset;\n    const firstEdgeIndexes = this._firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n\n    const mapAndFlag = this.userObjectsMapAndFlag();\n    const flags = mapAndFlag ? mapAndFlag.map : null;\n    const flag = mapAndFlag ? mapAndFlag.flag : 0;\n\n    const stackNodes = new Uint32Array(nodeCount);\n    const stackCurrentEdge = new Uint32Array(nodeCount);\n    const postOrderIndex2NodeOrdinal = new Uint32Array(nodeCount);\n    const nodeOrdinal2PostOrderIndex = new Uint32Array(nodeCount);\n    const visited = new Uint8Array(nodeCount);\n    let postOrderIndex = 0;\n\n    let stackTop = 0;\n    stackNodes[0] = rootNodeOrdinal;\n    stackCurrentEdge[0] = firstEdgeIndexes[rootNodeOrdinal];\n    visited[rootNodeOrdinal] = 1;\n\n    let iteration = 0;\n    while (true) {\n      ++iteration;\n      while (stackTop >= 0) {\n        const nodeOrdinal = stackNodes[stackTop];\n        const edgeIndex = stackCurrentEdge[stackTop];\n        const edgesEnd = firstEdgeIndexes[nodeOrdinal + 1];\n\n        if (edgeIndex < edgesEnd) {\n          stackCurrentEdge[stackTop] += edgeFieldsCount;\n          const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n          if (!this._isEssentialEdge(nodeOrdinal * nodeFieldCount, edgeType)) {\n            continue;\n          }\n          const childNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n          const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n          if (visited[childNodeOrdinal]) {\n            continue;\n          }\n          const nodeFlag = !flags || (flags[nodeOrdinal] & flag);\n          const childNodeFlag = !flags || (flags[childNodeOrdinal] & flag);\n          // We are skipping the edges from non-page-owned nodes to page-owned nodes.\n          // Otherwise the dominators for the objects that also were retained by debugger would be affected.\n          if (nodeOrdinal !== rootNodeOrdinal && childNodeFlag && !nodeFlag) {\n            continue;\n          }\n          ++stackTop;\n          stackNodes[stackTop] = childNodeOrdinal;\n          stackCurrentEdge[stackTop] = firstEdgeIndexes[childNodeOrdinal];\n          visited[childNodeOrdinal] = 1;\n        } else {\n          // Done with all the node children\n          nodeOrdinal2PostOrderIndex[nodeOrdinal] = postOrderIndex;\n          postOrderIndex2NodeOrdinal[postOrderIndex++] = nodeOrdinal;\n          --stackTop;\n        }\n      }\n\n      if (postOrderIndex === nodeCount || iteration > 1) {\n        break;\n      }\n      const errors = new HeapSnapshotProblemReport(`Heap snapshot: ${\n          nodeCount - postOrderIndex} nodes are unreachable from the root. Following nodes have only weak retainers:`);\n      const dumpNode = this.rootNode();\n      // Remove root from the result (last node in the array) and put it at the bottom of the stack so that it is\n      // visited after all orphan nodes and their subgraphs.\n      --postOrderIndex;\n      stackTop = 0;\n      stackNodes[0] = rootNodeOrdinal;\n      stackCurrentEdge[0] = firstEdgeIndexes[rootNodeOrdinal + 1];  // no need to reiterate its edges\n      for (let i = 0; i < nodeCount; ++i) {\n        if (visited[i] || !this._hasOnlyWeakRetainers(i)) {\n          continue;\n        }\n\n        // Add all nodes that have only weak retainers to traverse their subgraphs.\n        stackNodes[++stackTop] = i;\n        stackCurrentEdge[stackTop] = firstEdgeIndexes[i];\n        visited[i] = 1;\n\n        dumpNode.nodeIndex = i * nodeFieldCount;\n        const retainers = [];\n        for (let it = dumpNode.retainers(); it.hasNext(); it.next()) {\n          retainers.push(`${it.item().node().name()}@${it.item().node().id()}.${it.item().name()}`);\n        }\n        errors.addError(`${dumpNode.name()} @${dumpNode.id()}  weak retainers: ${retainers.join(', ')}`);\n      }\n      console.warn(errors.toString());\n    }\n\n    // If we already processed all orphan nodes that have only weak retainers and still have some orphans...\n    if (postOrderIndex !== nodeCount) {\n      const errors = new HeapSnapshotProblemReport(\n          'Still found ' + (nodeCount - postOrderIndex) + ' unreachable nodes in heap snapshot:');\n      const dumpNode = this.rootNode();\n      // Remove root from the result (last node in the array) and put it at the bottom of the stack so that it is\n      // visited after all orphan nodes and their subgraphs.\n      --postOrderIndex;\n      for (let i = 0; i < nodeCount; ++i) {\n        if (visited[i]) {\n          continue;\n        }\n        dumpNode.nodeIndex = i * nodeFieldCount;\n        errors.addError(dumpNode.name() + ' @' + dumpNode.id());\n        // Fix it by giving the node a postorder index anyway.\n        nodeOrdinal2PostOrderIndex[i] = postOrderIndex;\n        postOrderIndex2NodeOrdinal[postOrderIndex++] = i;\n      }\n      nodeOrdinal2PostOrderIndex[rootNodeOrdinal] = postOrderIndex;\n      postOrderIndex2NodeOrdinal[postOrderIndex++] = rootNodeOrdinal;\n      console.warn(errors.toString());\n    }\n\n    return {\n      postOrderIndex2NodeOrdinal: postOrderIndex2NodeOrdinal,\n      nodeOrdinal2PostOrderIndex: nodeOrdinal2PostOrderIndex\n    };\n  }\n\n  /**\n   * @param {number} nodeOrdinal\n   * @return {boolean}\n   */\n  _hasOnlyWeakRetainers(nodeOrdinal) {\n    const edgeTypeOffset = this._edgeTypeOffset;\n    const edgeWeakType = this._edgeWeakType;\n    const edgeShortcutType = this._edgeShortcutType;\n    const containmentEdges = this.containmentEdges;\n    const retainingEdges = this._retainingEdges;\n    const beginRetainerIndex = this._firstRetainerIndex[nodeOrdinal];\n    const endRetainerIndex = this._firstRetainerIndex[nodeOrdinal + 1];\n    for (let retainerIndex = beginRetainerIndex; retainerIndex < endRetainerIndex; ++retainerIndex) {\n      const retainerEdgeIndex = retainingEdges[retainerIndex];\n      const retainerEdgeType = containmentEdges[retainerEdgeIndex + edgeTypeOffset];\n      if (retainerEdgeType !== edgeWeakType && retainerEdgeType !== edgeShortcutType) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // The algorithm is based on the article:\n  // K. Cooper, T. Harvey and K. Kennedy \"A Simple, Fast Dominance Algorithm\"\n  // Softw. Pract. Exper. 4 (2001), pp. 1-10.\n  /**\n   * @param {!Uint32Array} postOrderIndex2NodeOrdinal\n   * @param {!Uint32Array} nodeOrdinal2PostOrderIndex\n   */\n  _buildDominatorTree(postOrderIndex2NodeOrdinal, nodeOrdinal2PostOrderIndex) {\n    const nodeFieldCount = this._nodeFieldCount;\n    const firstRetainerIndex = this._firstRetainerIndex;\n    const retainingNodes = this._retainingNodes;\n    const retainingEdges = this._retainingEdges;\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const edgeTypeOffset = this._edgeTypeOffset;\n    const edgeToNodeOffset = this._edgeToNodeOffset;\n    const firstEdgeIndexes = this._firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n    const rootNodeIndex = this._rootNodeIndex;\n\n    const mapAndFlag = this.userObjectsMapAndFlag();\n    const flags = mapAndFlag ? mapAndFlag.map : null;\n    const flag = mapAndFlag ? mapAndFlag.flag : 0;\n\n    const nodesCount = postOrderIndex2NodeOrdinal.length;\n    const rootPostOrderedIndex = nodesCount - 1;\n    const noEntry = nodesCount;\n    const dominators = new Uint32Array(nodesCount);\n    for (let i = 0; i < rootPostOrderedIndex; ++i) {\n      dominators[i] = noEntry;\n    }\n    dominators[rootPostOrderedIndex] = rootPostOrderedIndex;\n\n    // The affected array is used to mark entries which dominators\n    // have to be racalculated because of changes in their retainers.\n    const affected = new Uint8Array(nodesCount);\n    let nodeOrdinal;\n\n    {  // Mark the root direct children as affected.\n      nodeOrdinal = this._rootNodeIndex / nodeFieldCount;\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = firstEdgeIndexes[nodeOrdinal]; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n        if (!this._isEssentialEdge(this._rootNodeIndex, edgeType)) {\n          continue;\n        }\n        const childNodeOrdinal = containmentEdges[edgeIndex + edgeToNodeOffset] / nodeFieldCount;\n        affected[nodeOrdinal2PostOrderIndex[childNodeOrdinal]] = 1;\n      }\n    }\n\n    let changed = true;\n    while (changed) {\n      changed = false;\n      for (let postOrderIndex = rootPostOrderedIndex - 1; postOrderIndex >= 0; --postOrderIndex) {\n        if (affected[postOrderIndex] === 0) {\n          continue;\n        }\n        affected[postOrderIndex] = 0;\n        // If dominator of the entry has already been set to root,\n        // then it can't propagate any further.\n        if (dominators[postOrderIndex] === rootPostOrderedIndex) {\n          continue;\n        }\n        nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n        const nodeFlag = !flags || (flags[nodeOrdinal] & flag);\n        let newDominatorIndex = noEntry;\n        const beginRetainerIndex = firstRetainerIndex[nodeOrdinal];\n        const endRetainerIndex = firstRetainerIndex[nodeOrdinal + 1];\n        let orphanNode = true;\n        for (let retainerIndex = beginRetainerIndex; retainerIndex < endRetainerIndex; ++retainerIndex) {\n          const retainerEdgeIndex = retainingEdges[retainerIndex];\n          const retainerEdgeType = containmentEdges[retainerEdgeIndex + edgeTypeOffset];\n          const retainerNodeIndex = retainingNodes[retainerIndex];\n          if (!this._isEssentialEdge(retainerNodeIndex, retainerEdgeType)) {\n            continue;\n          }\n          orphanNode = false;\n          const retainerNodeOrdinal = retainerNodeIndex / nodeFieldCount;\n          const retainerNodeFlag = !flags || (flags[retainerNodeOrdinal] & flag);\n          // We are skipping the edges from non-page-owned nodes to page-owned nodes.\n          // Otherwise the dominators for the objects that also were retained by debugger would be affected.\n          if (retainerNodeIndex !== rootNodeIndex && nodeFlag && !retainerNodeFlag) {\n            continue;\n          }\n          let retanerPostOrderIndex = nodeOrdinal2PostOrderIndex[retainerNodeOrdinal];\n          if (dominators[retanerPostOrderIndex] !== noEntry) {\n            if (newDominatorIndex === noEntry) {\n              newDominatorIndex = retanerPostOrderIndex;\n            } else {\n              while (retanerPostOrderIndex !== newDominatorIndex) {\n                while (retanerPostOrderIndex < newDominatorIndex) {\n                  retanerPostOrderIndex = dominators[retanerPostOrderIndex];\n                }\n                while (newDominatorIndex < retanerPostOrderIndex) {\n                  newDominatorIndex = dominators[newDominatorIndex];\n                }\n              }\n            }\n            // If idom has already reached the root, it doesn't make sense\n            // to check other retainers.\n            if (newDominatorIndex === rootPostOrderedIndex) {\n              break;\n            }\n          }\n        }\n        // Make root dominator of orphans.\n        if (orphanNode) {\n          newDominatorIndex = rootPostOrderedIndex;\n        }\n        if (newDominatorIndex !== noEntry && dominators[postOrderIndex] !== newDominatorIndex) {\n          dominators[postOrderIndex] = newDominatorIndex;\n          changed = true;\n          nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n          const beginEdgeToNodeFieldIndex = firstEdgeIndexes[nodeOrdinal] + edgeToNodeOffset;\n          const endEdgeToNodeFieldIndex = firstEdgeIndexes[nodeOrdinal + 1];\n          for (let toNodeFieldIndex = beginEdgeToNodeFieldIndex; toNodeFieldIndex < endEdgeToNodeFieldIndex;\n               toNodeFieldIndex += edgeFieldsCount) {\n            const childNodeOrdinal = containmentEdges[toNodeFieldIndex] / nodeFieldCount;\n            affected[nodeOrdinal2PostOrderIndex[childNodeOrdinal]] = 1;\n          }\n        }\n      }\n    }\n\n    const dominatorsTree = new Uint32Array(nodesCount);\n    for (let postOrderIndex = 0, l = dominators.length; postOrderIndex < l; ++postOrderIndex) {\n      nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n      dominatorsTree[nodeOrdinal] = postOrderIndex2NodeOrdinal[dominators[postOrderIndex]];\n    }\n    return dominatorsTree;\n  }\n\n  /**\n   * @param {!Uint32Array} postOrderIndex2NodeOrdinal\n   */\n  _calculateRetainedSizes(postOrderIndex2NodeOrdinal) {\n    const nodeCount = this.nodeCount;\n    const nodes = this.nodes;\n    const nodeSelfSizeOffset = this._nodeSelfSizeOffset;\n    const nodeFieldCount = this._nodeFieldCount;\n    const dominatorsTree = this._dominatorsTree;\n    const retainedSizes = this._retainedSizes;\n\n    for (let nodeOrdinal = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      retainedSizes[nodeOrdinal] = nodes[nodeOrdinal * nodeFieldCount + nodeSelfSizeOffset];\n    }\n\n    // Propagate retained sizes for each node excluding root.\n    for (let postOrderIndex = 0; postOrderIndex < nodeCount - 1; ++postOrderIndex) {\n      const nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n      const dominatorOrdinal = dominatorsTree[nodeOrdinal];\n      retainedSizes[dominatorOrdinal] += retainedSizes[nodeOrdinal];\n    }\n  }\n\n  _buildDominatedNodes() {\n    // Builds up two arrays:\n    //  - \"dominatedNodes\" is a continuous array, where each node owns an\n    //    interval (can be empty) with corresponding dominated nodes.\n    //  - \"indexArray\" is an array of indexes in the \"dominatedNodes\"\n    //    with the same positions as in the _nodeIndex.\n    const indexArray = this._firstDominatedNodeIndex;\n    // All nodes except the root have dominators.\n    const dominatedNodes = this._dominatedNodes;\n\n    // Count the number of dominated nodes for each node. Skip the root (node at\n    // index 0) as it is the only node that dominates itself.\n    const nodeFieldCount = this._nodeFieldCount;\n    const dominatorsTree = this._dominatorsTree;\n\n    let fromNodeOrdinal = 0;\n    let toNodeOrdinal = this.nodeCount;\n    const rootNodeOrdinal = this._rootNodeIndex / nodeFieldCount;\n    if (rootNodeOrdinal === fromNodeOrdinal) {\n      fromNodeOrdinal = 1;\n    } else if (rootNodeOrdinal === toNodeOrdinal - 1) {\n      toNodeOrdinal = toNodeOrdinal - 1;\n    } else {\n      throw new Error('Root node is expected to be either first or last');\n    }\n    for (let nodeOrdinal = fromNodeOrdinal; nodeOrdinal < toNodeOrdinal; ++nodeOrdinal) {\n      ++indexArray[dominatorsTree[nodeOrdinal]];\n    }\n    // Put in the first slot of each dominatedNodes slice the count of entries\n    // that will be filled.\n    let firstDominatedNodeIndex = 0;\n    for (let i = 0, l = this.nodeCount; i < l; ++i) {\n      const dominatedCount = dominatedNodes[firstDominatedNodeIndex] = indexArray[i];\n      indexArray[i] = firstDominatedNodeIndex;\n      firstDominatedNodeIndex += dominatedCount;\n    }\n    indexArray[this.nodeCount] = dominatedNodes.length;\n    // Fill up the dominatedNodes array with indexes of dominated nodes. Skip the root (node at\n    // index 0) as it is the only node that dominates itself.\n    for (let nodeOrdinal = fromNodeOrdinal; nodeOrdinal < toNodeOrdinal; ++nodeOrdinal) {\n      const dominatorOrdinal = dominatorsTree[nodeOrdinal];\n      let dominatedRefIndex = indexArray[dominatorOrdinal];\n      dominatedRefIndex += (--dominatedNodes[dominatedRefIndex]);\n      dominatedNodes[dominatedRefIndex] = nodeOrdinal * nodeFieldCount;\n    }\n  }\n\n  /**\n   * Iterates children of a node.\n   *\n   * @param {number} nodeOrdinal The ordinal number representing the node.\n   * @param {function(number):boolean} edgeFilterCallback Callback that allows for filtering edge types.\n   * @param {function(number):void} childCallback Callback invoked with the ordinal number representing the child.\n   */\n  _iterateFilteredChildren(nodeOrdinal, edgeFilterCallback, childCallback) {\n    const beginEdgeIndex = this._firstEdgeIndexes[nodeOrdinal];\n    const endEdgeIndex = this._firstEdgeIndexes[nodeOrdinal + 1];\n    for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += this._edgeFieldsCount) {\n      const childNodeIndex = this.containmentEdges[edgeIndex + this._edgeToNodeOffset];\n      const childNodeOrdinal = childNodeIndex / this._nodeFieldCount;\n      const type = this.containmentEdges[edgeIndex + this._edgeTypeOffset];\n      if (!edgeFilterCallback(type)) {\n        continue;\n      }\n      childCallback(childNodeOrdinal);\n    }\n  }\n\n  /**\n   * Adds a string to the snapshot.\n   *\n   * @param {string} string added to the snapshot.\n   * @returns the index to refer to the string through snapshot.strings[index].\n   */\n  _addString(string) {\n    this.strings.push(string);\n    return this.strings.length - 1;\n  }\n\n  /**\n    * The phase propagates whether a node is attached or detached through the\n    * graph and adjusts the low-level representation of nodes.\n    *\n    * State propagation:\n    * 1. Any object reachable from an attached object is itself attached.\n    * 2. Any object reachable from a detached object that is not already\n    *    attached is considered detached.\n    *\n    * Representation:\n    * - Name of any detached node is changed from \"<Name>\"\" to\n    *   \"Detached <Name>\".\n    */\n  _propagateDOMState() {\n    if (this._nodeDetachednessOffset === -1) {\n      return;\n    }\n\n    console.time('propagateDOMState');\n\n    /** @type {!Uint8Array} */\n    const visited = new Uint8Array(this.nodeCount);\n    /** @type {!Array<number>} */\n    const attached = [];\n    /** @type {!Array<number>} */\n    const detached = [];\n\n    /** @type {!Map<number, number>} */\n    const stringIndexCache = new Map();\n\n    /**\n     * Adds a 'Detached ' prefix to the name of a node.\n     *\n     * @param {!HeapSnapshot} snapshot The snapshot to work on.\n     * @param {number} nodeIndex The index representing the node.\n     */\n    const addDetachedPrefixToNodeName = function(snapshot, nodeIndex) {\n      const oldStringIndex = snapshot.nodes[nodeIndex + snapshot._nodeNameOffset];\n      let newStringIndex = stringIndexCache.get(oldStringIndex);\n      if (newStringIndex === undefined) {\n        newStringIndex = snapshot._addString('Detached ' + snapshot.strings[oldStringIndex]);\n        stringIndexCache.set(oldStringIndex, newStringIndex);\n      }\n      snapshot.nodes[nodeIndex + snapshot._nodeNameOffset] = newStringIndex;\n    };\n\n    /**\n     * Processes a node represented by nodeOrdinal:\n     * - Changes its name based on newState.\n     * - Puts it onto working sets for attached or detached nodes.\n     *\n     * @param {!HeapSnapshot} snapshot The snapshot to work on.\n     * @param {number} nodeOrdinal The ordinal number representing the node.\n     * @param {number} newState New detached state for the node.\n     */\n    const processNode = function(snapshot, nodeOrdinal, newState) {\n      if (visited[nodeOrdinal]) {\n        return;\n      }\n\n      const nodeIndex = nodeOrdinal * snapshot._nodeFieldCount;\n\n      // Early bailout: Do not propagate the state (and name change) through JavaScript. Every\n      // entry point into embedder code is a node that knows its own state. All embedder nodes\n      // have their node type set to native.\n      if (snapshot.nodes[nodeIndex + snapshot._nodeTypeOffset] !== snapshot._nodeNativeType) {\n        visited[nodeOrdinal] = 1;\n        return;\n      }\n\n      snapshot.nodes[nodeIndex + snapshot._nodeDetachednessOffset] = newState;\n\n      if (newState === DOMLinkState.Attached) {\n        attached.push(nodeOrdinal);\n      } else if (newState === DOMLinkState.Detached) {\n        // Detached state: Rewire node name.\n        addDetachedPrefixToNodeName(snapshot, nodeIndex);\n        detached.push(nodeOrdinal);\n      }\n\n      visited[nodeOrdinal] = 1;\n    };\n\n    /**\n     * @param {!HeapSnapshot} snapshot\n     * @param {number} parentNodeOrdinal\n     * @param {number} newState\n     */\n    const propagateState = function(snapshot, parentNodeOrdinal, newState) {\n      snapshot._iterateFilteredChildren(\n          parentNodeOrdinal,\n          edgeType =>\n              ![snapshot._edgeHiddenType, snapshot._edgeInvisibleType, snapshot._edgeWeakType].includes(edgeType),\n          nodeOrdinal => processNode(snapshot, nodeOrdinal, newState));\n    };\n\n    // 1. We re-use the deserialized field to store the propagated state. While\n    //    the state for known nodes is already set, they still need to go\n    //    through processing to have their name adjusted and them enqueued in\n    //    the respective queues.\n    for (let nodeOrdinal = 0; nodeOrdinal < this.nodeCount; ++nodeOrdinal) {\n      const state = this.nodes[nodeOrdinal * this._nodeFieldCount + this._nodeDetachednessOffset];\n      // Bail out for objects that have no known state. For all other objects set that state.\n      if (state === DOMLinkState.Unknown) {\n        continue;\n      }\n      processNode(this, nodeOrdinal, state);\n    }\n    // 2. If the parent is attached, then the child is also attached.\n    while (attached.length !== 0) {\n      const nodeOrdinal = /** @type {number} */ (attached.pop());\n      propagateState(this, nodeOrdinal, DOMLinkState.Attached);\n    }\n    // 3. If the parent is not attached, then the child inherits the parent's state.\n    while (detached.length !== 0) {\n      const nodeOrdinal = /** @type {number} */ (detached.pop());\n      const nodeState = this.nodes[nodeOrdinal * this._nodeFieldCount + this._nodeDetachednessOffset];\n      // Ignore if the node has been found through propagating forward attached state.\n      if (nodeState === DOMLinkState.Attached) {\n        continue;\n      }\n      propagateState(this, nodeOrdinal, DOMLinkState.Detached);\n    }\n\n    console.timeEnd('propagateDOMState');\n  }\n\n  _buildSamples() {\n    const samples = this._rawSamples;\n    if (!samples || !samples.length) {\n      return;\n    }\n    const sampleCount = samples.length / 2;\n    const sizeForRange = new Array(sampleCount);\n    const timestamps = new Array(sampleCount);\n    const lastAssignedIds = new Array(sampleCount);\n\n    const timestampOffset = this._metaNode.sample_fields.indexOf('timestamp_us');\n    const lastAssignedIdOffset = this._metaNode.sample_fields.indexOf('last_assigned_id');\n    for (let i = 0; i < sampleCount; i++) {\n      sizeForRange[i] = 0;\n      timestamps[i] = (samples[2 * i + timestampOffset]) / 1000;\n      lastAssignedIds[i] = samples[2 * i + lastAssignedIdOffset];\n    }\n\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this._nodeFieldCount;\n    const node = this.rootNode();\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n\n      const nodeId = node.id();\n      // JS objects have odd ids, skip native objects.\n      if (nodeId % 2 === 0) {\n        continue;\n      }\n      const rangeIndex =\n          Platform.ArrayUtilities.lowerBound(lastAssignedIds, nodeId, Platform.ArrayUtilities.DEFAULT_COMPARATOR);\n      if (rangeIndex === sampleCount) {\n        // TODO: make heap profiler not allocate while taking snapshot\n        continue;\n      }\n      sizeForRange[rangeIndex] += node.selfSize();\n    }\n    this._samples = new HeapSnapshotModel.HeapSnapshotModel.Samples(timestamps, lastAssignedIds, sizeForRange);\n  }\n\n  _buildLocationMap() {\n    /** @type {!Map<number, !HeapSnapshotModel.HeapSnapshotModel.Location>} */\n    const map = new Map();\n    const locations = this._locations;\n\n    for (let i = 0; i < locations.length; i += this._locationFieldCount) {\n      const nodeIndex = locations[i + this._locationIndexOffset];\n      const scriptId = locations[i + this._locationScriptIdOffset];\n      const line = locations[i + this._locationLineOffset];\n      const col = locations[i + this._locationColumnOffset];\n      map.set(nodeIndex, new HeapSnapshotModel.HeapSnapshotModel.Location(scriptId, line, col));\n    }\n\n    this._locationMap = map;\n  }\n\n  /**\n   * @param {number} nodeIndex\n   * @return {?HeapSnapshotModel.HeapSnapshotModel.Location}\n   */\n  getLocation(nodeIndex) {\n    return this._locationMap.get(nodeIndex) || null;\n  }\n\n  /**\n   * @return {?HeapSnapshotModel.HeapSnapshotModel.Samples}\n   */\n  getSamples() {\n    return this._samples;\n  }\n\n  /**\n   * @protected\n   */\n  calculateFlags() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @protected\n   */\n  calculateStatistics() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @protected\n   * @return {?{map: !Uint32Array, flag: number}}\n   */\n  userObjectsMapAndFlag() {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param {string} baseSnapshotId\n   * @param {!Object.<string, !HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff>} baseSnapshotAggregates\n   * @return {!Object.<string, !HeapSnapshotModel.HeapSnapshotModel.Diff>}\n   */\n  calculateSnapshotDiff(baseSnapshotId, baseSnapshotAggregates) {\n    let snapshotDiff = this._snapshotDiffs[baseSnapshotId];\n    if (snapshotDiff) {\n      return snapshotDiff;\n    }\n    snapshotDiff = /** @type {!Object.<string, !HeapSnapshotModel.HeapSnapshotModel.Diff>} */ ({});\n\n    const aggregates = this.aggregates(true, 'allObjects');\n    for (const className in baseSnapshotAggregates) {\n      const baseAggregate = baseSnapshotAggregates[className];\n      const diff = this._calculateDiffForClass(baseAggregate, aggregates[className]);\n      if (diff) {\n        snapshotDiff[className] = diff;\n      }\n    }\n    const emptyBaseAggregate = new HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff();\n    for (const className in aggregates) {\n      if (className in baseSnapshotAggregates) {\n        continue;\n      }\n      const classDiff = this._calculateDiffForClass(emptyBaseAggregate, aggregates[className]);\n      if (classDiff) {\n        snapshotDiff[className] = classDiff;\n      }\n    }\n\n    this._snapshotDiffs[baseSnapshotId] = snapshotDiff;\n    return snapshotDiff;\n  }\n\n  /**\n   * @param {!HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff} baseAggregate\n   * @param {!HeapSnapshotModel.HeapSnapshotModel.Aggregate} aggregate\n   * @return {?HeapSnapshotModel.HeapSnapshotModel.Diff}\n   */\n  _calculateDiffForClass(baseAggregate, aggregate) {\n    const baseIds = baseAggregate.ids;\n    const baseIndexes = baseAggregate.indexes;\n    const baseSelfSizes = baseAggregate.selfSizes;\n\n    const indexes = aggregate ? aggregate.idxs : [];\n\n    let i = 0;\n    let j = 0;\n    const l = baseIds.length;\n    const m = indexes.length;\n    const diff = new HeapSnapshotModel.HeapSnapshotModel.Diff();\n\n    const nodeB = this.createNode(indexes[j]);\n    while (i < l && j < m) {\n      const nodeAId = baseIds[i];\n      if (nodeAId < nodeB.id()) {\n        diff.deletedIndexes.push(baseIndexes[i]);\n        diff.removedCount++;\n        diff.removedSize += baseSelfSizes[i];\n        ++i;\n      } else if (\n          nodeAId >\n          nodeB.id()) {  // Native nodes(e.g. dom groups) may have ids less than max JS object id in the base snapshot\n        diff.addedIndexes.push(indexes[j]);\n        diff.addedCount++;\n        diff.addedSize += nodeB.selfSize();\n        nodeB.nodeIndex = indexes[++j];\n      } else {  // nodeAId === nodeB.id()\n        ++i;\n        nodeB.nodeIndex = indexes[++j];\n      }\n    }\n    while (i < l) {\n      diff.deletedIndexes.push(baseIndexes[i]);\n      diff.removedCount++;\n      diff.removedSize += baseSelfSizes[i];\n      ++i;\n    }\n    while (j < m) {\n      diff.addedIndexes.push(indexes[j]);\n      diff.addedCount++;\n      diff.addedSize += nodeB.selfSize();\n      nodeB.nodeIndex = indexes[++j];\n    }\n    diff.countDelta = diff.addedCount - diff.removedCount;\n    diff.sizeDelta = diff.addedSize - diff.removedSize;\n    if (!diff.addedCount && !diff.removedCount) {\n      return null;\n    }\n    return diff;\n  }\n\n  /**\n   * @param {number} snapshotObjectId\n   */\n  _nodeForSnapshotObjectId(snapshotObjectId) {\n    for (let it = this._allNodes(); it.hasNext(); it.next()) {\n      if (it.node.id() === snapshotObjectId) {\n        return it.node;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {number} snapshotObjectId\n   * @return {?string}\n   */\n  nodeClassName(snapshotObjectId) {\n    const node = this._nodeForSnapshotObjectId(snapshotObjectId);\n    if (node) {\n      return node.className();\n    }\n    return null;\n  }\n\n  /**\n   * @param {string} name\n   * @return {!Array.<number>}\n   */\n  idsOfObjectsWithName(name) {\n    const ids = [];\n    for (let it = this._allNodes(); it.hasNext(); it.next()) {\n      if (it.item().name() === name) {\n        ids.push(it.item().id());\n      }\n    }\n    return ids;\n  }\n\n  /**\n   * @param {number} nodeIndex\n   * @return {!HeapSnapshotEdgesProvider}\n   */\n  createEdgesProvider(nodeIndex) {\n    const node = this.createNode(nodeIndex);\n    const filter = this.containmentEdgesFilter();\n    const indexProvider = new HeapSnapshotEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.edges(), indexProvider);\n  }\n\n  /**\n   * @param {number} nodeIndex\n   * @param {?function(!HeapSnapshotEdge):boolean} filter\n   * @return {!HeapSnapshotEdgesProvider}\n   */\n  createEdgesProviderForTest(nodeIndex, filter) {\n    const node = this.createNode(nodeIndex);\n    const indexProvider = new HeapSnapshotEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.edges(), indexProvider);\n  }\n\n  /**\n   * @return {?function(!HeapSnapshotEdge):boolean}\n   */\n  retainingEdgesFilter() {\n    return null;\n  }\n\n  /**\n   * @return {?function(!HeapSnapshotEdge):boolean}\n   */\n  containmentEdgesFilter() {\n    return null;\n  }\n\n  /**\n   * @param {number} nodeIndex\n   * @return {!HeapSnapshotEdgesProvider}\n   */\n  createRetainingEdgesProvider(nodeIndex) {\n    const node = this.createNode(nodeIndex);\n    const filter = this.retainingEdgesFilter();\n    const indexProvider = new HeapSnapshotRetainerEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.retainers(), indexProvider);\n  }\n\n  /**\n   * @param {string} baseSnapshotId\n   * @param {string} className\n   * @return {!HeapSnapshotNodesProvider}\n   */\n  createAddedNodesProvider(baseSnapshotId, className) {\n    const snapshotDiff = this._snapshotDiffs[baseSnapshotId];\n    const diffForClass = snapshotDiff[className];\n    return new HeapSnapshotNodesProvider(this, diffForClass.addedIndexes);\n  }\n\n  /**\n   * @param {!Array.<number>} nodeIndexes\n   * @return {!HeapSnapshotNodesProvider}\n   */\n  createDeletedNodesProvider(nodeIndexes) {\n    return new HeapSnapshotNodesProvider(this, nodeIndexes);\n  }\n\n  /**\n   * @param {string} className\n   * @param {!HeapSnapshotModel.HeapSnapshotModel.NodeFilter} nodeFilter\n   * @return {!HeapSnapshotNodesProvider}\n   */\n  createNodesProviderForClass(className, nodeFilter) {\n    return new HeapSnapshotNodesProvider(this, this.aggregatesWithFilter(nodeFilter)[className].idxs);\n  }\n\n  /**\n   * @return {number}\n   */\n  _maxJsNodeId() {\n    const nodeFieldCount = this._nodeFieldCount;\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    let id = 0;\n    for (let nodeIndex = this._nodeIdOffset; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      const nextId = nodes[nodeIndex];\n      // JS objects have odd ids, skip native objects.\n      if (nextId % 2 === 0) {\n        continue;\n      }\n      if (id < nextId) {\n        id = nextId;\n      }\n    }\n    return id;\n  }\n\n  /**\n   * @return {!HeapSnapshotModel.HeapSnapshotModel.StaticData}\n   */\n  updateStaticData() {\n    return new HeapSnapshotModel.HeapSnapshotModel.StaticData(\n        this.nodeCount, this._rootNodeIndex, this.totalSize, this._maxJsNodeId());\n  }\n}\n\nconst HeapSnapshotMetainfo = class {\n  constructor() {\n    /**\n     * @type {!Array<string>}\n     */\n    this.location_fields = [];\n\n    /**\n     * @type {!Array<string>}\n     */\n    this.node_fields = [];\n\n    /**\n     * @type {!Array<!Array<string>>}\n     */\n    this.node_types = [];\n\n    /**\n     * @type {!Array<string>}\n     */\n    this.edge_fields = [];\n\n    /**\n     * @type {!Array<!Array<string>>}\n     */\n    this.edge_types = [];\n\n    /**\n     * @type {!Array<string>}\n     */\n    this.trace_function_info_fields = [];\n\n    /**\n     * @type {!Array<string>}\n     */\n    this.trace_node_fields = [];\n\n    /**\n     * @type {!Array<string>}\n     */\n    this.sample_fields = [];\n\n    /**\n     * @type {!Object<string, string>}\n     */\n    this.type_strings = {};\n  }\n};\n\nexport class HeapSnapshotHeader {\n  constructor() {\n    // New format.\n    this.title = '';\n    this.meta = new HeapSnapshotMetainfo();\n    this.node_count = 0;\n    this.edge_count = 0;\n    this.trace_function_count = 0;\n    this.root_index = 0;\n  }\n}\n\nexport class HeapSnapshotItemProvider {\n  /**\n   * @param {!HeapSnapshotItemIterator} iterator\n   * @param {!HeapSnapshotItemIndexProvider} indexProvider\n   */\n  constructor(iterator, indexProvider) {\n    this._iterator = iterator;\n    this._indexProvider = indexProvider;\n    this._isEmpty = !iterator.hasNext();\n    /** @type {?Array.<number>} */\n    this._iterationOrder = null;\n    this._currentComparator = null;\n    this._sortedPrefixLength = 0;\n    this._sortedSuffixLength = 0;\n  }\n\n  _createIterationOrder() {\n    if (this._iterationOrder) {\n      return;\n    }\n    this._iterationOrder = [];\n    for (let iterator = this._iterator; iterator.hasNext(); iterator.next()) {\n      this._iterationOrder.push(iterator.item().itemIndex());\n    }\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isEmpty() {\n    return this._isEmpty;\n  }\n\n  /**\n   * @param {number} begin\n   * @param {number} end\n   * @return {!HeapSnapshotModel.HeapSnapshotModel.ItemsRange}\n   */\n  serializeItemsRange(begin, end) {\n    this._createIterationOrder();\n    if (begin > end) {\n      throw new Error('Start position > end position: ' + begin + ' > ' + end);\n    }\n\n    if (!this._iterationOrder) {\n      throw new Error('Iteration order undefined');\n    }\n\n    if (end > this._iterationOrder.length) {\n      end = this._iterationOrder.length;\n    }\n    if (this._sortedPrefixLength < end && begin < this._iterationOrder.length - this._sortedSuffixLength &&\n        this._currentComparator) {\n      const currentComparator = this._currentComparator;\n      this.sort(\n          currentComparator, this._sortedPrefixLength, this._iterationOrder.length - 1 - this._sortedSuffixLength,\n          begin, end - 1);\n      if (begin <= this._sortedPrefixLength) {\n        this._sortedPrefixLength = end;\n      }\n      if (end >= this._iterationOrder.length - this._sortedSuffixLength) {\n        this._sortedSuffixLength = this._iterationOrder.length - begin;\n      }\n    }\n    let position = begin;\n    const count = end - begin;\n    const result = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      const itemIndex = this._iterationOrder[position++];\n      const item = this._indexProvider.itemForIndex(itemIndex);\n      result[i] = item.serialize();\n    }\n    return new HeapSnapshotModel.HeapSnapshotModel.ItemsRange(begin, end, this._iterationOrder.length, result);\n  }\n\n  /**\n   * @param {!HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig} comparator\n   */\n  sortAndRewind(comparator) {\n    this._currentComparator = comparator;\n    this._sortedPrefixLength = 0;\n    this._sortedSuffixLength = 0;\n  }\n\n  /**\n   * @param {!HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig} comparator\n   * @param {number} leftBound\n   * @param {number} rightBound\n   * @param {number} windowLeft\n   * @param {number} windowRight\n   */\n  sort(comparator, leftBound, rightBound, windowLeft, windowRight) {\n    throw new Error('Not implemented');\n  }\n}\n\nexport class HeapSnapshotEdgesProvider extends HeapSnapshotItemProvider {\n  /**\n   * @param {!HeapSnapshot} snapshot\n   * @param {?function(!HeapSnapshotEdge):boolean} filter\n   * @param {!HeapSnapshotEdgeIterator|!HeapSnapshotRetainerEdgeIterator} edgesIter\n   * @param {!HeapSnapshotItemIndexProvider} indexProvider\n   */\n  constructor(snapshot, filter, edgesIter, indexProvider) {\n    const iter = filter ?\n        new HeapSnapshotFilteredIterator(edgesIter, /** @type {function(!HeapSnapshotItem):boolean} */ (filter)) :\n        edgesIter;\n    super(iter, indexProvider);\n    this.snapshot = snapshot;\n  }\n\n  /**\n   * @param {!HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig} comparator\n   * @param {number} leftBound\n   * @param {number} rightBound\n   * @param {number} windowLeft\n   * @param {number} windowRight\n   * @override\n   */\n  sort(comparator, leftBound, rightBound, windowLeft, windowRight) {\n    const fieldName1 = comparator.fieldName1;\n    const fieldName2 = comparator.fieldName2;\n    const ascending1 = comparator.ascending1;\n    const ascending2 = comparator.ascending2;\n\n    const edgeA = /** @type {!HeapSnapshotEdge} */ (this._iterator.item()).clone();\n    const edgeB = edgeA.clone();\n    const nodeA = this.snapshot.createNode();\n    const nodeB = this.snapshot.createNode();\n\n    /**\n     * @param {boolean} ascending\n     * @param {number} indexA\n     * @param {number} indexB\n     */\n    function compareEdgeFieldName(ascending, indexA, indexB) {\n      edgeA.edgeIndex = indexA;\n      edgeB.edgeIndex = indexB;\n      if (edgeB.name() === '__proto__') {\n        return -1;\n      }\n      if (edgeA.name() === '__proto__') {\n        return 1;\n      }\n      const result = edgeA.hasStringName() === edgeB.hasStringName() ?\n          (edgeA.name() < edgeB.name() ? -1 : (edgeA.name() > edgeB.name() ? 1 : 0)) :\n          (edgeA.hasStringName() ? -1 : 1);\n      return ascending ? result : -result;\n    }\n\n    /**\n     * @param {string} fieldName\n     * @param {boolean} ascending\n     * @param {number} indexA\n     * @param {number} indexB\n     */\n    function compareNodeField(fieldName, ascending, indexA, indexB) {\n      edgeA.edgeIndex = indexA;\n      nodeA.nodeIndex = edgeA.nodeIndex();\n      const valueA = /** @type {*} */ (nodeA)[fieldName]();\n\n      edgeB.edgeIndex = indexB;\n      nodeB.nodeIndex = edgeB.nodeIndex();\n      const valueB = /** @type {*} */ (nodeB)[fieldName]();\n\n      const result = valueA < valueB ? -1 : (valueA > valueB ? 1 : 0);\n      return ascending ? result : -result;\n    }\n\n    /**\n     * @param {number} indexA\n     * @param {number} indexB\n     */\n    function compareEdgeAndNode(indexA, indexB) {\n      let result = compareEdgeFieldName(ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareNodeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    /**\n     * @param {number} indexA\n     * @param {number} indexB\n     */\n    function compareNodeAndEdge(indexA, indexB) {\n      let result = compareNodeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareEdgeFieldName(ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    /**\n     * @param {number} indexA\n     * @param {number} indexB\n     */\n    function compareNodeAndNode(indexA, indexB) {\n      let result = compareNodeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareNodeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    if (!this._iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    if (fieldName1 === '!edgeName') {\n      Platform.ArrayUtilities.sortRange(\n          this._iterationOrder, compareEdgeAndNode, leftBound, rightBound, windowLeft, windowRight);\n    } else if (fieldName2 === '!edgeName') {\n      Platform.ArrayUtilities.sortRange(\n          this._iterationOrder, compareNodeAndEdge, leftBound, rightBound, windowLeft, windowRight);\n    } else {\n      Platform.ArrayUtilities.sortRange(\n          this._iterationOrder, compareNodeAndNode, leftBound, rightBound, windowLeft, windowRight);\n    }\n  }\n}\n\nexport class HeapSnapshotNodesProvider extends HeapSnapshotItemProvider {\n  /**\n   * @param {!HeapSnapshot} snapshot\n   * @param {!Array<number>|!Uint32Array} nodeIndexes\n   */\n  constructor(snapshot, nodeIndexes) {\n    const indexProvider = new HeapSnapshotNodeIndexProvider(snapshot);\n    const it = new HeapSnapshotIndexRangeIterator(indexProvider, nodeIndexes);\n    super(it, indexProvider);\n    this.snapshot = snapshot;\n  }\n\n  /**\n   * @param {number} snapshotObjectId\n   * @return {number}\n   */\n  nodePosition(snapshotObjectId) {\n    this._createIterationOrder();\n    const node = this.snapshot.createNode();\n    let i = 0;\n    if (!this._iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    for (; i < this._iterationOrder.length; i++) {\n      node.nodeIndex = this._iterationOrder[i];\n      if (node.id() === snapshotObjectId) {\n        break;\n      }\n    }\n    if (i === this._iterationOrder.length) {\n      return -1;\n    }\n    const targetNodeIndex = this._iterationOrder[i];\n    let smallerCount = 0;\n\n    const currentComparator =\n        /** @type {!HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig} */ (this._currentComparator);\n    const compare = this._buildCompareFunction(currentComparator);\n    for (let i = 0; i < this._iterationOrder.length; i++) {\n      if (compare(this._iterationOrder[i], targetNodeIndex) < 0) {\n        ++smallerCount;\n      }\n    }\n    return smallerCount;\n  }\n\n  /**\n   * @param {!HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig} comparator\n   * @return {function(number,number):number}\n   */\n  _buildCompareFunction(comparator) {\n    const nodeA = this.snapshot.createNode();\n    const nodeB = this.snapshot.createNode();\n    const fieldAccessor1 = /** @type {*} */ (nodeA)[comparator.fieldName1];\n    const fieldAccessor2 = /** @type {*} */ (nodeA)[comparator.fieldName2];\n    const ascending1 = comparator.ascending1 ? 1 : -1;\n    const ascending2 = comparator.ascending2 ? 1 : -1;\n\n    /**\n     * @param {function():*} fieldAccessor\n     * @param {number} ascending\n     * @return {number}\n     */\n    function sortByNodeField(fieldAccessor, ascending) {\n      const valueA = fieldAccessor.call(nodeA);\n      const valueB = fieldAccessor.call(nodeB);\n      return valueA < valueB ? -ascending : (valueA > valueB ? ascending : 0);\n    }\n\n    /**\n     * @param {number} indexA\n     * @param {number} indexB\n     * @return {number}\n     */\n    function sortByComparator(indexA, indexB) {\n      nodeA.nodeIndex = indexA;\n      nodeB.nodeIndex = indexB;\n      let result = sortByNodeField(fieldAccessor1, ascending1);\n      if (result === 0) {\n        result = sortByNodeField(fieldAccessor2, ascending2);\n      }\n      return result || indexA - indexB;\n    }\n\n    return sortByComparator;\n  }\n\n  /**\n   * @param {!HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig} comparator\n   * @param {number} leftBound\n   * @param {number} rightBound\n   * @param {number} windowLeft\n   * @param {number} windowRight\n   * @override\n   */\n  sort(comparator, leftBound, rightBound, windowLeft, windowRight) {\n    if (!this._iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    Platform.ArrayUtilities.sortRange(\n        this._iterationOrder, this._buildCompareFunction(comparator), leftBound, rightBound, windowLeft, windowRight);\n  }\n}\n\nexport class JSHeapSnapshot extends HeapSnapshot {\n  /**\n   * @param {!Profile} profile\n   * @param {!HeapSnapshotProgress} progress\n   */\n  constructor(profile, progress) {\n    super(profile, progress);\n    this._nodeFlags = {\n      // bit flags\n      canBeQueried: 1,\n      detachedDOMTreeNode: 2,\n      pageObject: 4  // The idea is to track separately the objects owned by the page and the objects owned by debugger.\n    };\n    this._lazyStringCache = {};\n    this.initialize();\n\n    /** @type {!Uint32Array} */\n    this._flags;\n  }\n\n  /**\n   * @override\n   * @param {number=} nodeIndex\n   * @return {!JSHeapSnapshotNode}\n   */\n  createNode(nodeIndex) {\n    return new JSHeapSnapshotNode(this, nodeIndex === undefined ? -1 : nodeIndex);\n  }\n\n  /**\n   * @override\n   * @param {number} edgeIndex\n   * @return {!JSHeapSnapshotEdge}\n   */\n  createEdge(edgeIndex) {\n    return new JSHeapSnapshotEdge(this, edgeIndex);\n  }\n\n  /**\n   * @override\n   * @param {number} retainerIndex\n   * @return {!JSHeapSnapshotRetainerEdge}\n   */\n  createRetainingEdge(retainerIndex) {\n    return new JSHeapSnapshotRetainerEdge(this, retainerIndex);\n  }\n\n  /**\n   * @override\n   * @return {function(!HeapSnapshotEdge):boolean}\n   */\n  containmentEdgesFilter() {\n    return edge => !edge.isInvisible();\n  }\n\n  /**\n   * @override\n   * @return {function(!HeapSnapshotEdge):boolean}\n   */\n  retainingEdgesFilter() {\n    const containmentEdgesFilter = this.containmentEdgesFilter();\n    /**\n     * @param {!HeapSnapshotEdge} edge\n     */\n    function filter(edge) {\n      return containmentEdgesFilter(edge) && !edge.node().isRoot() && !edge.isWeak();\n    }\n    return filter;\n  }\n\n  /**\n   * @override\n   */\n  calculateFlags() {\n    this._flags = new Uint32Array(this.nodeCount);\n    this._markDetachedDOMTreeNodes();\n    this._markQueriableHeapObjects();\n    this._markPageOwnedNodes();\n  }\n\n  /**\n   * @override\n   */\n  calculateDistances() {\n    /**\n     * @param {!HeapSnapshotNode} node\n     * @param {!HeapSnapshotEdge} edge\n     * @return {boolean}\n     */\n    function filter(node, edge) {\n      if (node.isHidden()) {\n        return edge.name() !== 'sloppy_function_map' || node.rawName() !== 'system / NativeContext';\n      }\n      if (node.isArray()) {\n        // DescriptorArrays are fixed arrays used to hold instance descriptors.\n        // The format of the these objects is:\n        //   [0]: Number of descriptors\n        //   [1]: Either Smi(0) if uninitialized, or a pointer to small fixed array:\n        //          [0]: pointer to fixed array with enum cache\n        //          [1]: either Smi(0) or pointer to fixed array with indices\n        //   [i*3+2]: i-th key\n        //   [i*3+3]: i-th type\n        //   [i*3+4]: i-th descriptor\n        // As long as maps may share descriptor arrays some of the descriptor\n        // links may not be valid for all the maps. We just skip\n        // all the descriptor links when calculating distances.\n        // For more details see http://crbug.com/413608\n        if (node.rawName() !== '(map descriptors)') {\n          return true;\n        }\n        const index = parseInt(edge.name(), 10);\n        return index < 2 || (index % 3) !== 1;\n      }\n      return true;\n    }\n    super.calculateDistances(filter);\n  }\n\n  /**\n   * @override\n   * @protected\n   * @param {!HeapSnapshotNode} node\n   * @return {boolean}\n   */\n  isUserRoot(node) {\n    return node.isUserRoot() || node.isDocumentDOMTreesRoot();\n  }\n\n  /**\n   * @override\n   * @return {?{map: !Uint32Array, flag: number}}\n   */\n  userObjectsMapAndFlag() {\n    return {map: this._flags, flag: this._nodeFlags.pageObject};\n  }\n\n  /**\n   * @param {!HeapSnapshotNode} node\n   * @return {number}\n   */\n  _flagsOfNode(node) {\n    return this._flags[node.nodeIndex / this._nodeFieldCount];\n  }\n\n  _markDetachedDOMTreeNodes() {\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this._nodeFieldCount;\n    const nodeNativeType = this._nodeNativeType;\n    const nodeTypeOffset = this._nodeTypeOffset;\n    const flag = this._nodeFlags.detachedDOMTreeNode;\n    const node = this.rootNode();\n    for (let nodeIndex = 0, ordinal = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount, ordinal++) {\n      const nodeType = nodes[nodeIndex + nodeTypeOffset];\n      if (nodeType !== nodeNativeType) {\n        continue;\n      }\n      node.nodeIndex = nodeIndex;\n      if (node.name().startsWith('Detached ')) {\n        this._flags[ordinal] |= flag;\n      }\n    }\n  }\n\n  _markQueriableHeapObjects() {\n    // Allow runtime properties query for objects accessible from Window objects\n    // via regular properties, and for DOM wrappers. Trying to access random objects\n    // can cause a crash due to insonsistent state of internal properties of wrappers.\n    const flag = this._nodeFlags.canBeQueried;\n    const hiddenEdgeType = this._edgeHiddenType;\n    const internalEdgeType = this._edgeInternalType;\n    const invisibleEdgeType = this._edgeInvisibleType;\n    const weakEdgeType = this._edgeWeakType;\n    const edgeToNodeOffset = this._edgeToNodeOffset;\n    const edgeTypeOffset = this._edgeTypeOffset;\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const containmentEdges = this.containmentEdges;\n    const nodeFieldCount = this._nodeFieldCount;\n    const firstEdgeIndexes = this._firstEdgeIndexes;\n\n    const flags = /** @type {!Uint32Array} */ (this._flags);\n    /**\n     * @type {!Array<number>}\n     */\n    const list = [];\n\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      if (iter.edge.node().isUserRoot()) {\n        list.push(iter.edge.node().nodeIndex / nodeFieldCount);\n      }\n    }\n\n    while (list.length) {\n      const nodeOrdinal = /** @type {number} */ (list.pop());\n      if (flags[nodeOrdinal] & flag) {\n        continue;\n      }\n      flags[nodeOrdinal] |= flag;\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const childNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (flags[childNodeOrdinal] & flag) {\n          continue;\n        }\n        const type = containmentEdges[edgeIndex + edgeTypeOffset];\n        if (type === hiddenEdgeType || type === invisibleEdgeType || type === internalEdgeType ||\n            type === weakEdgeType) {\n          continue;\n        }\n        list.push(childNodeOrdinal);\n      }\n    }\n  }\n\n  _markPageOwnedNodes() {\n    const edgeShortcutType = this._edgeShortcutType;\n    const edgeElementType = this._edgeElementType;\n    const edgeToNodeOffset = this._edgeToNodeOffset;\n    const edgeTypeOffset = this._edgeTypeOffset;\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const edgeWeakType = this._edgeWeakType;\n    const firstEdgeIndexes = this._firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n    const nodeFieldCount = this._nodeFieldCount;\n    const nodesCount = this.nodeCount;\n\n    const flags = /** @type {!Uint32Array} */ (this._flags);\n    const pageObjectFlag = this._nodeFlags.pageObject;\n\n    const nodesToVisit = new Uint32Array(nodesCount);\n    let nodesToVisitLength = 0;\n\n    const rootNodeOrdinal = this._rootNodeIndex / nodeFieldCount;\n    const node = this.rootNode();\n\n    // Populate the entry points. They are Window objects and DOM Tree Roots.\n    for (let edgeIndex = firstEdgeIndexes[rootNodeOrdinal], endEdgeIndex = firstEdgeIndexes[rootNodeOrdinal + 1];\n         edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n      const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n      const nodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n      if (edgeType === edgeElementType) {\n        node.nodeIndex = nodeIndex;\n        if (!node.isDocumentDOMTreesRoot()) {\n          continue;\n        }\n      } else if (edgeType !== edgeShortcutType) {\n        continue;\n      }\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      nodesToVisit[nodesToVisitLength++] = nodeOrdinal;\n      flags[nodeOrdinal] |= pageObjectFlag;\n    }\n\n    // Mark everything reachable with the pageObject flag.\n    while (nodesToVisitLength) {\n      const nodeOrdinal = nodesToVisit[--nodesToVisitLength];\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const childNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (flags[childNodeOrdinal] & pageObjectFlag) {\n          continue;\n        }\n        const type = containmentEdges[edgeIndex + edgeTypeOffset];\n        if (type === edgeWeakType) {\n          continue;\n        }\n        nodesToVisit[nodesToVisitLength++] = childNodeOrdinal;\n        flags[childNodeOrdinal] |= pageObjectFlag;\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  calculateStatistics() {\n    const nodeFieldCount = this._nodeFieldCount;\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeTypeOffset = this._nodeTypeOffset;\n    const nodeSizeOffset = this._nodeSelfSizeOffset;\n    const nodeNativeType = this._nodeNativeType;\n    const nodeCodeType = this._nodeCodeType;\n    const nodeConsStringType = this._nodeConsStringType;\n    const nodeSlicedStringType = this._nodeSlicedStringType;\n    const distances = this._nodeDistances;\n    let sizeNative = 0;\n    let sizeCode = 0;\n    let sizeStrings = 0;\n    let sizeJSArrays = 0;\n    let sizeSystem = 0;\n    const node = this.rootNode();\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      const nodeSize = nodes[nodeIndex + nodeSizeOffset];\n      const ordinal = nodeIndex / nodeFieldCount;\n      if (distances[ordinal] >= HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance) {\n        sizeSystem += nodeSize;\n        continue;\n      }\n      const nodeType = nodes[nodeIndex + nodeTypeOffset];\n      node.nodeIndex = nodeIndex;\n      if (nodeType === nodeNativeType) {\n        sizeNative += nodeSize;\n      } else if (nodeType === nodeCodeType) {\n        sizeCode += nodeSize;\n      } else if (nodeType === nodeConsStringType || nodeType === nodeSlicedStringType || node.type() === 'string') {\n        sizeStrings += nodeSize;\n      } else if (node.name() === 'Array') {\n        sizeJSArrays += this._calculateArraySize(node);\n      }\n    }\n    this._statistics = new HeapSnapshotModel.HeapSnapshotModel.Statistics();\n    this._statistics.total = this.totalSize;\n    this._statistics.v8heap = this.totalSize - sizeNative;\n    this._statistics.native = sizeNative;\n    this._statistics.code = sizeCode;\n    this._statistics.jsArrays = sizeJSArrays;\n    this._statistics.strings = sizeStrings;\n    this._statistics.system = sizeSystem;\n  }\n\n  /**\n   * @param {!HeapSnapshotNode} node\n   * @return {number}\n   */\n  _calculateArraySize(node) {\n    let size = node.selfSize();\n    const beginEdgeIndex = node.edgeIndexesStart();\n    const endEdgeIndex = node.edgeIndexesEnd();\n    const containmentEdges = this.containmentEdges;\n    const strings = this.strings;\n    const edgeToNodeOffset = this._edgeToNodeOffset;\n    const edgeTypeOffset = this._edgeTypeOffset;\n    const edgeNameOffset = this._edgeNameOffset;\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const edgeInternalType = this._edgeInternalType;\n    for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n      const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n      if (edgeType !== edgeInternalType) {\n        continue;\n      }\n      const edgeName = strings[containmentEdges[edgeIndex + edgeNameOffset]];\n      if (edgeName !== 'elements') {\n        continue;\n      }\n      const elementsNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n      node.nodeIndex = elementsNodeIndex;\n      if (node.retainersCount() === 1) {\n        size += node.selfSize();\n      }\n      break;\n    }\n    return size;\n  }\n\n  /**\n   * @return {!HeapSnapshotModel.HeapSnapshotModel.Statistics}\n   */\n  getStatistics() {\n    return /** @type {!HeapSnapshotModel.HeapSnapshotModel.Statistics} */ (this._statistics);\n  }\n}\n\nexport class JSHeapSnapshotNode extends HeapSnapshotNode {\n  /**\n   * @param {!JSHeapSnapshot} snapshot\n   * @param {number=} nodeIndex\n   */\n  constructor(snapshot, nodeIndex) {\n    super(snapshot, nodeIndex);\n  }\n\n  /**\n   * @return {boolean}\n   */\n  canBeQueried() {\n    const snapshot = /** @type {!JSHeapSnapshot} */ (this._snapshot);\n    const flags = snapshot._flagsOfNode(this);\n    return Boolean(flags & snapshot._nodeFlags.canBeQueried);\n  }\n\n  /**\n   * @return {string}\n   * @override\n   */\n  rawName() {\n    return super.name();\n  }\n\n  /**\n   * @override\n   * @return {string}\n   */\n  name() {\n    const snapshot = this._snapshot;\n    if (this.rawType() === snapshot._nodeConsStringType) {\n      let string = snapshot._lazyStringCache[this.nodeIndex];\n      if (typeof string === 'undefined') {\n        string = this._consStringName();\n        snapshot._lazyStringCache[this.nodeIndex] = string;\n      }\n      return string;\n    }\n    return this.rawName();\n  }\n\n  /**\n   * @return {string}\n   */\n  _consStringName() {\n    const snapshot = this._snapshot;\n    const consStringType = snapshot._nodeConsStringType;\n    const edgeInternalType = snapshot._edgeInternalType;\n    const edgeFieldsCount = snapshot._edgeFieldsCount;\n    const edgeToNodeOffset = snapshot._edgeToNodeOffset;\n    const edgeTypeOffset = snapshot._edgeTypeOffset;\n    const edgeNameOffset = snapshot._edgeNameOffset;\n    const strings = snapshot.strings;\n    const edges = snapshot.containmentEdges;\n    const firstEdgeIndexes = snapshot._firstEdgeIndexes;\n    const nodeFieldCount = snapshot._nodeFieldCount;\n    const nodeTypeOffset = snapshot._nodeTypeOffset;\n    const nodeNameOffset = snapshot._nodeNameOffset;\n    const nodes = snapshot.nodes;\n    const nodesStack = [];\n    nodesStack.push(this.nodeIndex);\n    let name = '';\n\n    while (nodesStack.length && name.length < 1024) {\n      const nodeIndex = /** @type {number} */ (nodesStack.pop());\n      if (nodes[nodeIndex + nodeTypeOffset] !== consStringType) {\n        name += strings[nodes[nodeIndex + nodeNameOffset]];\n        continue;\n      }\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      let firstNodeIndex = 0;\n      let secondNodeIndex = 0;\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex && (!firstNodeIndex || !secondNodeIndex);\n           edgeIndex += edgeFieldsCount) {\n        const edgeType = edges[edgeIndex + edgeTypeOffset];\n        if (edgeType === edgeInternalType) {\n          const edgeName = strings[edges[edgeIndex + edgeNameOffset]];\n          if (edgeName === 'first') {\n            firstNodeIndex = edges[edgeIndex + edgeToNodeOffset];\n          } else if (edgeName === 'second') {\n            secondNodeIndex = edges[edgeIndex + edgeToNodeOffset];\n          }\n        }\n      }\n      nodesStack.push(secondNodeIndex);\n      nodesStack.push(firstNodeIndex);\n    }\n    return name;\n  }\n\n  /**\n   * @override\n   * @return {string}\n   */\n  className() {\n    const type = this.type();\n    switch (type) {\n      case 'hidden':\n        return '(system)';\n      case 'object':\n      case 'native':\n        return this.name();\n      case 'code':\n        return '(compiled code)';\n      default:\n        return '(' + type + ')';\n    }\n  }\n\n  /**\n   * @override\n   * @return {number}\n   */\n  classIndex() {\n    const snapshot = this._snapshot;\n    const nodes = snapshot.nodes;\n    const type = nodes[this.nodeIndex + snapshot._nodeTypeOffset];\n    if (type === snapshot._nodeObjectType || type === snapshot._nodeNativeType) {\n      return nodes[this.nodeIndex + snapshot._nodeNameOffset];\n    }\n    return -1 - type;\n  }\n\n  /**\n   * @override\n   * @return {number}\n   */\n  id() {\n    const snapshot = this._snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot._nodeIdOffset];\n  }\n\n  /**\n   * @return {boolean}\n   * @override\n   */\n  isHidden() {\n    return this.rawType() === this._snapshot._nodeHiddenType;\n  }\n\n  /**\n   * @return {boolean}\n   * @override\n   */\n  isArray() {\n    return this.rawType() === this._snapshot._nodeArrayType;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isSynthetic() {\n    return this.rawType() === this._snapshot._nodeSyntheticType;\n  }\n\n  /**\n   * @return {boolean}\n   * @override\n   */\n  isUserRoot() {\n    return !this.isSynthetic();\n  }\n\n  /**\n   * @return {boolean}\n   * @override\n   */\n  isDocumentDOMTreesRoot() {\n    return this.isSynthetic() && this.name() === '(Document DOM trees)';\n  }\n\n  /**\n   * @override\n   * @return {!HeapSnapshotModel.HeapSnapshotModel.Node}\n   */\n  serialize() {\n    const result = super.serialize();\n    const snapshot = /** @type {!JSHeapSnapshot} */ (this._snapshot);\n    const flags = snapshot._flagsOfNode(this);\n    if (flags & snapshot._nodeFlags.canBeQueried) {\n      result.canBeQueried = true;\n    }\n    if (flags & snapshot._nodeFlags.detachedDOMTreeNode) {\n      result.detachedDOMTreeNode = true;\n    }\n    return result;\n  }\n}\n\nexport class JSHeapSnapshotEdge extends HeapSnapshotEdge {\n  /**\n   * @param {!JSHeapSnapshot} snapshot\n   * @param {number=} edgeIndex\n   */\n  constructor(snapshot, edgeIndex) {\n    super(snapshot, edgeIndex);\n  }\n\n  /**\n   * @override\n   * @return {!JSHeapSnapshotEdge}\n   */\n  clone() {\n    const snapshot = /** @type {!JSHeapSnapshot} */ (this._snapshot);\n    return new JSHeapSnapshotEdge(snapshot, this.edgeIndex);\n  }\n\n  /**\n   * @override\n   * @return {boolean}\n   */\n  hasStringName() {\n    if (!this.isShortcut()) {\n      return this._hasStringName();\n    }\n    // @ts-ignore parseInt is successful against numbers.\n    return isNaN(parseInt(this._name(), 10));\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isElement() {\n    return this.rawType() === this._snapshot._edgeElementType;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isHidden() {\n    return this.rawType() === this._snapshot._edgeHiddenType;\n  }\n\n  /**\n   * @return {boolean}\n   * @override\n   */\n  isWeak() {\n    return this.rawType() === this._snapshot._edgeWeakType;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isInternal() {\n    return this.rawType() === this._snapshot._edgeInternalType;\n  }\n\n  /**\n   * @return {boolean}\n   * @override\n   */\n  isInvisible() {\n    return this.rawType() === this._snapshot._edgeInvisibleType;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isShortcut() {\n    return this.rawType() === this._snapshot._edgeShortcutType;\n  }\n\n  /**\n   * @override\n   * @return {string}\n   */\n  name() {\n    const name = this._name();\n    if (!this.isShortcut()) {\n      return String(name);\n    }\n    // @ts-ignore parseInt is successful against numbers.\n    const numName = parseInt(name, 10);\n    return String(isNaN(numName) ? name : numName);\n  }\n\n  /**\n   * @override\n   * @return {string}\n   */\n  toString() {\n    const name = this.name();\n    switch (this.type()) {\n      case 'context':\n        return '->' + name;\n      case 'element':\n        return '[' + name + ']';\n      case 'weak':\n        return '[[' + name + ']]';\n      case 'property':\n        return name.indexOf(' ') === -1 ? '.' + name : '[\"' + name + '\"]';\n      case 'shortcut':\n        if (typeof name === 'string') {\n          return name.indexOf(' ') === -1 ? '.' + name : '[\"' + name + '\"]';\n        }\n        return '[' + name + ']';\n      case 'internal':\n      case 'hidden':\n      case 'invisible':\n        return '{' + name + '}';\n    }\n    return '?' + name + '?';\n  }\n\n  /**\n   * @return {boolean}\n   */\n  _hasStringName() {\n    const type = this.rawType();\n    const snapshot = this._snapshot;\n    return type !== snapshot._edgeElementType && type !== snapshot._edgeHiddenType;\n  }\n\n  /**\n   * @return {string|number}\n   */\n  _name() {\n    return this._hasStringName() ? this._snapshot.strings[this._nameOrIndex()] : this._nameOrIndex();\n  }\n\n  /**\n   * @return {number}\n   */\n  _nameOrIndex() {\n    return this._edges[this.edgeIndex + this._snapshot._edgeNameOffset];\n  }\n\n  /**\n   * @override\n   * @return {number}\n   */\n  rawType() {\n    return this._edges[this.edgeIndex + this._snapshot._edgeTypeOffset];\n  }\n}\n\nexport class JSHeapSnapshotRetainerEdge extends HeapSnapshotRetainerEdge {\n  /**\n   * @param {!JSHeapSnapshot} snapshot\n   * @param {number} retainerIndex\n   */\n  constructor(snapshot, retainerIndex) {\n    super(snapshot, retainerIndex);\n  }\n\n  /**\n   * @override\n   * @return {!JSHeapSnapshotRetainerEdge}\n   */\n  clone() {\n    const snapshot = /** @type {!JSHeapSnapshot} */ (this._snapshot);\n    return new JSHeapSnapshotRetainerEdge(snapshot, this.retainerIndex());\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isHidden() {\n    return this._edge().isHidden();\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isInternal() {\n    return this._edge().isInternal();\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isInvisible() {\n    return this._edge().isInvisible();\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isShortcut() {\n    return this._edge().isShortcut();\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isWeak() {\n    return this._edge().isWeak();\n  }\n}\n\n/**\n * @typedef {!{\n *   count: number,\n *   distance: number,\n *   self: number,\n *   maxRet: number,\n *   name: ?string,\n *   idxs: !Array<number>\n * }}\n */\n// @ts-ignore typedef\nexport let AggregatedInfo;\n"]}