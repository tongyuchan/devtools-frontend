{"version":3,"file":"BottomUpProfileDataGrid.js","sourceRoot":"","sources":["../../../../../front_end/profiler/BottomUpProfileDataGrid.js"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2009 280 North Inc. All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n// Bottom Up Profiling shows the entire callstack backwards:\n// The root node is a representation of each individual function called, and each child of that node represents\n// a reverse-callstack showing how many of those calls came from it. So, unlike top-down, the statistics in\n// each child still represent the root node. We have to be particularly careful of recursion with this mode\n// because a root node can represent itself AND an ancestor.\n\nimport * as Platform from '../platform/platform.js';\nimport * as SDK from '../sdk/sdk.js';  // eslint-disable-line no-unused-vars\nimport * as UI from '../ui/ui.js';     // eslint-disable-line no-unused-vars\n\nimport {Formatter, ProfileDataGridNode, ProfileDataGridTree} from './ProfileDataGrid.js';  // eslint-disable-line no-unused-vars\nimport {TopDownProfileDataGridTree} from './TopDownProfileDataGrid.js';  // eslint-disable-line no-unused-vars\n\n/** @typedef {{\n *    ancestor: !SDK.ProfileTreeModel.ProfileNode,\n *    focusNode: !SDK.ProfileTreeModel.ProfileNode,\n *    totalAccountedFor: boolean,\n * }}\n */\n// @ts-ignore typedef\nexport let NodeInfo;\n\nexport class BottomUpProfileDataGridNode extends ProfileDataGridNode {\n  /**\n   * @param {!SDK.ProfileTreeModel.ProfileNode} profileNode\n   * @param {!TopDownProfileDataGridTree} owningTree\n   */\n  constructor(profileNode, owningTree) {\n    super(profileNode, owningTree, profileNode.parent !== null && Boolean(profileNode.parent.parent));\n    /** @type {!Array<!NodeInfo> | undefined} */\n    this._remainingNodeInfos = [];\n  }\n\n  /**\n   * @param {!BottomUpProfileDataGridNode | !BottomUpProfileDataGridTree} container\n   */\n  static _sharedPopulate(container) {\n    if (container._remainingNodeInfos === undefined) {\n      return;\n    }\n    const remainingNodeInfos = container._remainingNodeInfos;\n    const count = remainingNodeInfos.length;\n\n    for (let index = 0; index < count; ++index) {\n      const nodeInfo = remainingNodeInfos[index];\n      const ancestor = nodeInfo.ancestor;\n      const focusNode = nodeInfo.focusNode;\n      let child = /** @type {?BottomUpProfileDataGridNode} */ (container.findChild(ancestor));\n\n      // If we already have this child, then merge the data together.\n      if (child) {\n        const totalAccountedFor = nodeInfo.totalAccountedFor;\n\n        child.self += focusNode.self;\n\n        if (!totalAccountedFor) {\n          child.total += focusNode.total;\n        }\n      } else {\n        // If not, add it as a true ancestor.\n        // In heavy mode, we take our visual identity from ancestor node...\n        child = new BottomUpProfileDataGridNode(ancestor, /** @type {!TopDownProfileDataGridTree} */ (container.tree));\n\n        if (ancestor !== focusNode) {\n          // But the actual statistics from the \"root\" node (bottom of the callstack).\n          child.self = focusNode.self;\n          child.total = focusNode.total;\n        }\n\n        container.appendChild(child);\n      }\n\n      const parent = ancestor.parent;\n      if (parent && parent.parent) {\n        nodeInfo.ancestor = parent;\n        if (!child._remainingNodeInfos) {\n          child._remainingNodeInfos = [];\n        }\n        child._remainingNodeInfos.push(nodeInfo);\n      }\n    }\n\n    delete container._remainingNodeInfos;\n  }\n\n  /**\n   * @param {!ProfileDataGridNode} profileDataGridNode\n   */\n  _takePropertiesFromProfileDataGridNode(profileDataGridNode) {\n    this.save();\n    this.self = profileDataGridNode.self;\n    this.total = profileDataGridNode.total;\n  }\n\n  /**\n   * When focusing, we keep just the members of the callstack.\n   * @param {!ProfileDataGridNode} child\n   */\n  _keepOnlyChild(child) {\n    this.save();\n\n    this.removeChildren();\n    this.appendChild(child);\n  }\n\n  /**\n   * @param {string} aCallUID\n   */\n  _exclude(aCallUID) {\n    if (this._remainingNodeInfos) {\n      this.populate();\n    }\n\n    this.save();\n\n    const children = this.children;\n    let index = this.children.length;\n\n    while (index--) {\n      /** @type {!BottomUpProfileDataGridNode} */ (children[index])._exclude(aCallUID);\n    }\n\n    const child = this.childrenByCallUID.get(aCallUID);\n\n    if (child) {\n      this.merge(child, true);\n    }\n  }\n\n  /**\n   * @override\n   */\n  restore() {\n    super.restore();\n\n    if (!this.children.length) {\n      this.setHasChildren(this._willHaveChildren(this.profileNode));\n    }\n  }\n\n  /**\n   * @override\n   * @param {!ProfileDataGridNode} child\n   * @param {boolean} shouldAbsorb\n   */\n  merge(child, shouldAbsorb) {\n    this.self -= child.self;\n    super.merge(child, shouldAbsorb);\n  }\n\n  /**\n   * @override\n   */\n  populateChildren() {\n    BottomUpProfileDataGridNode._sharedPopulate(this);\n  }\n\n  /**\n   * @param {!SDK.ProfileTreeModel.ProfileNode} profileNode\n   */\n  _willHaveChildren(profileNode) {\n    // In bottom up mode, our parents are our children since we display an inverted tree.\n    // However, we don't want to show the very top parent since it is redundant.\n    return Boolean(profileNode.parent && profileNode.parent.parent);\n  }\n}\n\nexport class BottomUpProfileDataGridTree extends ProfileDataGridTree {\n  /**\n   * @param {!Formatter} formatter\n   * @param {!UI.SearchableView.SearchableView} searchableView\n   * @param {!SDK.ProfileTreeModel.ProfileNode} rootProfileNode\n   * @param {number} total\n   */\n  constructor(formatter, searchableView, rootProfileNode, total) {\n    super(formatter, searchableView, total);\n    this.deepSearch = false;\n\n    // Iterate each node in pre-order.\n    let profileNodeUIDs = 0;\n    const profileNodeGroups = [[], [rootProfileNode]];\n    /** @type {!Map<string, !Set<number>>} */\n    const visitedProfileNodesForCallUID = new Map();\n\n    /** @type {!Array<!NodeInfo> | undefined} */\n    this._remainingNodeInfos = [];\n\n    for (let profileNodeGroupIndex = 0; profileNodeGroupIndex < profileNodeGroups.length; ++profileNodeGroupIndex) {\n      const parentProfileNodes = profileNodeGroups[profileNodeGroupIndex];\n      const profileNodes = profileNodeGroups[++profileNodeGroupIndex];\n      const count = profileNodes.length;\n\n      /** @type {!WeakMap<!SDK.ProfileTreeModel.ProfileNode, number>} */\n      const profileNodeUIDValues = new WeakMap();\n\n      for (let index = 0; index < count; ++index) {\n        const profileNode = profileNodes[index];\n\n        if (!profileNodeUIDValues.get(profileNode)) {\n          profileNodeUIDValues.set(profileNode, ++profileNodeUIDs);\n        }\n\n        if (profileNode.parent) {\n          // The total time of this ancestor is accounted for if we're in any form of recursive cycle.\n          let visitedNodes = visitedProfileNodesForCallUID.get(profileNode.callUID);\n          let totalAccountedFor = false;\n\n          if (!visitedNodes) {\n            visitedNodes = new Set();\n            visitedProfileNodesForCallUID.set(profileNode.callUID, visitedNodes);\n          } else {\n            // The total time for this node has already been accounted for iff one of it's parents has already been visited.\n            // We can do this check in this style because we are traversing the tree in pre-order.\n            const parentCount = parentProfileNodes.length;\n            for (let parentIndex = 0; parentIndex < parentCount; ++parentIndex) {\n              const parentUID = profileNodeUIDValues.get(parentProfileNodes[parentIndex]);\n              if (parentUID && visitedNodes.has(parentUID)) {\n                totalAccountedFor = true;\n                break;\n              }\n            }\n          }\n\n          const uid = profileNodeUIDValues.get(profileNode);\n          if (uid) {\n            visitedNodes.add(uid);\n          }\n\n          this._remainingNodeInfos.push(\n              {ancestor: profileNode, focusNode: profileNode, totalAccountedFor: totalAccountedFor});\n        }\n\n        const children = profileNode.children;\n        if (children.length) {\n          profileNodeGroups.push(parentProfileNodes.concat([profileNode]));\n          profileNodeGroups.push(children);\n        }\n      }\n    }\n\n    // Populate the top level nodes.\n    ProfileDataGridNode.populate(this);\n\n    return this;\n  }\n\n  /**\n   * When focusing, we keep the entire callstack up to this ancestor.\n   * @override\n   * @param {!ProfileDataGridNode} profileDataGridNode\n   */\n  focus(profileDataGridNode) {\n    if (!profileDataGridNode) {\n      return;\n    }\n\n    this.save();\n\n    let currentNode = profileDataGridNode;\n    let focusNode = profileDataGridNode;\n\n    while (currentNode.parent && (currentNode instanceof BottomUpProfileDataGridNode)) {\n      currentNode._takePropertiesFromProfileDataGridNode(profileDataGridNode);\n\n      focusNode = currentNode;\n      currentNode = /** @type {!ProfileDataGridNode} */ (currentNode.parent);\n\n      if (currentNode instanceof BottomUpProfileDataGridNode) {\n        currentNode._keepOnlyChild(focusNode);\n      }\n    }\n\n    this.children = [focusNode];\n    this.total = profileDataGridNode.total;\n  }\n\n  /**\n   * @override\n   * @param {!ProfileDataGridNode} profileDataGridNode\n   */\n  exclude(profileDataGridNode) {\n    if (!profileDataGridNode) {\n      return;\n    }\n\n    this.save();\n\n    const excludedCallUID = profileDataGridNode.callUID;\n    const excludedTopLevelChild = this.childrenByCallUID.get(excludedCallUID);\n\n    // If we have a top level node that is excluded, get rid of it completely (not keeping children),\n    // since bottom up data relies entirely on the root node.\n    if (excludedTopLevelChild) {\n      Platform.ArrayUtilities.removeElement(this.children, excludedTopLevelChild);\n    }\n\n    const children = this.children;\n    const count = children.length;\n\n    for (let index = 0; index < count; ++index) {\n      /** @type {!BottomUpProfileDataGridNode} */ (children[index])._exclude(excludedCallUID);\n    }\n\n    if (this.lastComparator) {\n      this.sort(this.lastComparator, true);\n    }\n  }\n\n  /**\n   * @override\n   */\n  populateChildren() {\n    BottomUpProfileDataGridNode._sharedPopulate(this);\n  }\n}\n"]}