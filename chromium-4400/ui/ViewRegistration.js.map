{"version":3,"file":"ViewRegistration.js","sourceRoot":"","sources":["../../../../../front_end/ui/ViewRegistration.ts"],"names":[],"mappings":"AAIA,OAAO,EAAC,EAAE,EAAC,MAAM,yBAAyB,CAAC;AAC3C,OAAO,KAAK,IAAI,MAAM,iBAAiB,CAAC;AAGxC,OAAO,EAAC,iBAAiB,EAAC,MAAM,kBAAkB,CAAC;AAInD,MAAM,wBAAwB,GAA6B,EAAE,CAAC;AAoG9D,MAAM,SAAS,GAAG,IAAI,GAAG,EAAU,CAAC;AACpC,MAAM,UAAU,qBAAqB,CAAC,YAA8B;IAClE,MAAM,MAAM,GAAG,YAAY,CAAC,EAAE,CAAC;IAC/B,IAAI,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;QACzB,MAAM,IAAI,KAAK,CAAC,sBAAsB,MAAM,MAAM,IAAI,KAAK,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;KACxE;IACD,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACtB,wBAAwB,CAAC,IAAI,CAAC,IAAI,iBAAiB,CAAC,YAAY,CAAC,CAAC,CAAC;AACrE,CAAC;AAED,MAAM,UAAU,2BAA2B;IACzC,OAAO,wBAAwB,CAAC,MAAM,CAClC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,mBAAmB,CAAC,EAAC,UAAU,EAAE,IAAI,CAAC,UAAU,EAAE,EAAE,SAAS,EAAE,IAAI,CAAC,SAAS,EAAE,EAAC,CAAC,CAAC,CAAC;AACtH,CAAC;AAED,MAAM,2BAA2B,GAAwC,EAAE,CAAC;AAE5E,MAAM,mBAAmB,GAAG,IAAI,GAAG,EAAsB,CAAC;AAE1D,MAAM,UAAU,wBAAwB,CAAC,YAA0C;IACjF,MAAM,YAAY,GAAG,YAAY,CAAC,IAAI,CAAC;IACvC,IAAI,mBAAmB,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;QACzC,MAAM,IAAI,KAAK,CAAC,8CAA8C,YAAY,GAAG,CAAC,CAAC;KAChF;IACD,mBAAmB,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;IACtC,2BAA2B,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;AACjD,CAAC;AAED,MAAM,UAAU,8BAA8B;IAC5C,OAAO,2BAA2B,CAAC;AACrC,CAAC;AAED,MAAM,CAAC,MAAM,0BAA0B,GAAG;IACxC,QAAQ,EAAE,EAAE,CAAA,UAAU;IACtB,MAAM,EAAE,EAAE,CAAA,QAAQ;IAClB,cAAc,EAAE,EAAE,CAAA,gBAAgB;IAClC,KAAK,EAAE,EAAE,CAAA,OAAO;IAChB,OAAO,EAAE,EAAE,CAAA,SAAS;IACpB,QAAQ,EAAE,EAAE,CAAA,UAAU;IACtB,OAAO,EAAE,EAAE,CAAA,SAAS;CACrB,CAAC","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../platform/platform.js';\nimport {ls} from '../platform/platform.js';\nimport * as Root from '../root/root.js';\n\nimport type {ViewLocationResolver} from './View.js';\nimport {PreRegisteredView} from './ViewManager.js';\n\nimport type {Widget} from './Widget.js';\n\nconst registeredViewExtensions: Array<PreRegisteredView> = [];\n\nexport const enum ViewPersistence {\n  CLOSEABLE = 'closeable',\n  PERMANENT = 'permanent',\n  TRANSIENT = 'transient',\n}\n\nexport const enum ViewLocationValues {\n  PANEL = 'panel',\n  SETTINGS_VIEW = 'settings-view',\n  ELEMENTS_SIDEBAR = 'elements-sidebar',\n  SOURCES_SIDEBAR_BOTTOM = 'sources.sidebar-bottom',\n  NAVIGATOR_VIEW = 'navigator-view',\n  DRAWER_VIEW = 'drawer-view',\n  NETWORK_SIDEBAR = 'network-sidebar',\n}\n\nexport interface ViewRegistration {\n  /**\n   * The name of the experiment a view is associated with. Enabling and disabling the declared\n   * experiment will enable and disable the view respectively.\n   */\n  experiment?: Root.Runtime.ExperimentName;\n  /**\n   * A condition represented as a string the view's availability depends on. Conditions come\n   * from the queryParamsObject defined in Runtime and just as the experiment field, they determine the availability\n   * of the view. A condition can be negated by prepending a ‘!’ to the value of the condition\n   * property and in that case the behaviour of the view's availability will be inverted.\n   */\n  condition?: Root.Runtime.ConditionName;\n  /**\n   * The command added to the command menu used to show the view. It usually follows the shape Show <title> as it must\n   * not be localized at declaration since it is localized internally when appending the commands to the command menu.\n   * The existing duplication of the declaration of the title is expected to be removed once the migration to the version\n   * 2 of the localization model has been completed (crbug.com/1136655).\n   */\n  commandPrompt: string;\n  /**\n   * A UI string used as the title of the view.\n   */\n  title: () => Platform.UIString.LocalizedString;\n\n  /**\n   * Whether the view is permanently visible or can be opened temporarily.\n   */\n  persistence?: ViewPersistence;\n  /**\n   * Unique identifier of the view.\n   */\n  id: string;\n  /**\n   * An identifier for the location of the view. The location is resolved by\n   * an extension of type '@UI.ViewLocationResolver'.\n   */\n  location?: ViewLocationValues;\n  /**\n   * Whether the view has a toolbar.\n   */\n  hasToolbar?: boolean;\n  /**\n   * Returns an instance of the class that wraps the view.\n   * The common pattern for implementing this function is loading the module with the wrapping 'Widget'\n   * lazily loaded. As an example:\n   *\n   * ```js\n   * let loadedElementsModule;\n   *\n   * async function loadElementsModule() {\n   *\n   *   if (!loadedElementsModule) {\n   *     loadedElementsModule = await import('./elements.js');\n   *   }\n   *   return loadedElementsModule;\n   * }\n   * UI.ViewManager.registerViewExtension({\n   *   <...>\n   *   async loadView() {\n   *      const Elements = await loadElementsModule();\n   *      return Elements.ElementsPanel.ElementsPanel.instance();\n   *   },\n   *   <...>\n   * });\n   * ```\n   */\n  loadView: () => Promise<Widget>;\n  /**\n   * Used to sort the views that appear in a shared location.\n   */\n  order?: number;\n  /**\n   * The names of the settings the registered view performs as UI for.\n   */\n  settings?: Array<string>;\n  /**\n   * Words used to find the view in the Command Menu.\n   */\n  tags?: Array<() => Platform.UIString.LocalizedString>;\n}\n\nconst viewIdSet = new Set<string>();\nexport function registerViewExtension(registration: ViewRegistration): void {\n  const viewId = registration.id;\n  if (viewIdSet.has(viewId)) {\n    throw new Error(`Duplicate view id '${viewId}': ${new Error().stack}`);\n  }\n  viewIdSet.add(viewId);\n  registeredViewExtensions.push(new PreRegisteredView(registration));\n}\n\nexport function getRegisteredViewExtensions(): Array<PreRegisteredView> {\n  return registeredViewExtensions.filter(\n      view => Root.Runtime.Runtime.isDescriptorEnabled({experiment: view.experiment(), condition: view.condition()}));\n}\n\nconst registeredLocationResolvers: Array<LocationResolverRegistration> = [];\n\nconst viewLocationNameSet = new Set<ViewLocationValues>();\n\nexport function registerLocationResolver(registration: LocationResolverRegistration): void {\n  const locationName = registration.name;\n  if (viewLocationNameSet.has(locationName)) {\n    throw new Error(`Duplicate view location name registration '${locationName}'`);\n  }\n  viewLocationNameSet.add(locationName);\n  registeredLocationResolvers.push(registration);\n}\n\nexport function getRegisteredLocationResolvers(): Array<LocationResolverRegistration> {\n  return registeredLocationResolvers;\n}\n\nexport const ViewLocationCategoryValues = {\n  ELEMENTS: ls`Elements`,\n  DRAWER: ls`Drawer`,\n  DRAWER_SIDEBAR: ls`Drawer sidebar`,\n  PANEL: ls`Panel`,\n  NETWORK: ls`Network`,\n  SETTINGS: ls`Settings`,\n  SOURCES: ls`Sources`,\n};\n\ntype ViewLocationCategory = typeof ViewLocationCategoryValues[keyof typeof ViewLocationCategoryValues];\n\nexport interface LocationResolverRegistration {\n  name: ViewLocationValues;\n  category: ViewLocationCategory;\n  loadResolver: () => Promise<ViewLocationResolver>;\n}\n"]}